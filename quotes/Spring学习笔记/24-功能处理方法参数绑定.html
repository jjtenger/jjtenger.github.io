<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '7.4.2',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: true,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"manual","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.json',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    },
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="到目前为止，请求已经能交给我们的处理器进行处理了，接下来的事情是要进行收集数据啦，接下来我们看看我们能从请求中收集到哪些数据，如下图：其中绑定的参数分为两个部分： 默认自动绑定的参数 通过注释绑定的参数 默认自动绑定的参数Request和ResponseServletRequest&#x2F;HttpServletRequest和ServletResponse&#x2F;HttpServletResponse">
<meta property="og:type" content="website">
<meta property="og:title" content="JJT-个人Wiki">
<meta property="og:url" content="https:&#x2F;&#x2F;hexo-pages-1300861231.cos-website.ap-shanghai.myqcloud.com&#x2F;quotes&#x2F;Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0&#x2F;24-%E5%8A%9F%E8%83%BD%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95%E5%8F%82%E6%95%B0%E7%BB%91%E5%AE%9A.html">
<meta property="og:site_name" content="JJT-个人Wiki">
<meta property="og:description" content="到目前为止，请求已经能交给我们的处理器进行处理了，接下来的事情是要进行收集数据啦，接下来我们看看我们能从请求中收集到哪些数据，如下图：其中绑定的参数分为两个部分： 默认自动绑定的参数 通过注释绑定的参数 默认自动绑定的参数Request和ResponseServletRequest&#x2F;HttpServletRequest和ServletResponse&#x2F;HttpServletResponse">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https:&#x2F;&#x2F;hexo-1300861231.cos.ap-shanghai.myqcloud.com&#x2F;1584800393_20200321221017193_27458.jpg">
<meta property="og:image" content="https:&#x2F;&#x2F;hexo-1300861231.cos.ap-shanghai.myqcloud.com&#x2F;1584800393_20200321221016375_16532.jpg">
<meta property="og:image" content="https:&#x2F;&#x2F;hexo-1300861231.cos.ap-shanghai.myqcloud.com&#x2F;1584800392_20200321221016165_28128.jpg">
<meta property="og:updated_time" content="2020-12-15T11:07:33.036Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https:&#x2F;&#x2F;hexo-1300861231.cos.ap-shanghai.myqcloud.com&#x2F;1584800393_20200321221017193_27458.jpg">

<link rel="canonical" href="https://hexo-pages-1300861231.cos-website.ap-shanghai.myqcloud.com/quotes/Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/24-%E5%8A%9F%E8%83%BD%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95%E5%8F%82%E6%95%B0%E7%BB%91%E5%AE%9A">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: false,
    isPage: true,
    isArchive: false
  };
</script>

  <title> | JJT-个人Wiki
  </title>
  








  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">JJT-个人Wiki</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">you see see you one day day</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="搜索..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
  
  

          <div class="content">
            

  <div class="posts-expand">
    
    
    
    <div class="post-block" lang="zh-CN">
      <header class="post-header">

<h1 class="post-title" itemprop="name headline">
</h1>

<div class="post-meta">
  
  <ul class="breadcrumb">
          
            <li><a href="/quotes/">QUOTES</a></li>
            <li><a href="/quotes/Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">SPRING学习笔记</a></li>
            <li>24-功能处理方法参数绑定</li>
          
  </ul>

</div>

</header>

      
      
      
      <div class="post-body">
          <p>到目前为止，请求已经能交给我们的处理器进行处理了，接下来的事情是要进行收集数据啦，接下来我们看看我们能从请求中收集到哪些数据，如下图：</p><p><img src="https://hexo-1300861231.cos.ap-shanghai.myqcloud.com/1584800393_20200321221017193_27458.jpg" alt></p><p>其中绑定的参数分为两个部分：</p><ul>
<li>默认自动绑定的参数</li>
<li>通过注释绑定的参数</li>
</ul><h1>默认自动绑定的参数</h1><h2 id="Request和Response">Request和Response</h2><p>ServletRequest/HttpServletRequest和ServletResponse/HttpServletResponse</p><a id="more"></a>






<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/requestOrResponse"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">requestOrResponse</span> <span class="params">(ServletRequest servletRequest, HttpServletRequest httpServletRequest, </span></span></span><br><span class="line"><span class="function"><span class="params">ServletResponse servletResponse, HttpServletResponse httpServletResponse)</span></span></span><br></pre></td></tr></table></figure>
<p>Spring Web MVC框架会自动帮助我们把相应的Servlet请求/响应（Servlet API）作为参数传递过来。</p>
<h2 id="InputStream、OutputStream或Reader、Writer">InputStream、OutputStream或Reader、Writer</h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/inputOrOutBody"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inputOrOutBody</span><span class="params">(InputStream requestBodyIn, OutputStream responseBodyOut)</span> <span class="keyword">throws</span> IOException </span>&#123;  </span><br><span class="line">   responseBodyOut.write(<span class="string">"success"</span>.getBytes());  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>requestBodyIn：获取请求的内容区字节流，等价于request.getInputStream();</p>
<p>responseBodyOut：获取相应的内容区字节流，等价于response.getOutputStream()。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/readerOrWriteBody"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readerOrWriteBody</span><span class="params">(Reader reader, Writer writer)</span> <span class="keyword">throws</span> IOException </span>&#123;  </span><br><span class="line">   writer.write(<span class="string">"hello"</span>);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>reader：获取请求的内容区字符流，等价于request.getReader();</p>
<p>writer：获取相应的内容区字符流，等价于response.getWriter()。</p>
<p><strong>InputStream/OutputStream和Reader/Writer两组不能同时使用，只能使用其中的一组。</strong></p>
<h2 id="WebRequest、NativeWebRequest">WebRequest、NativeWebRequest</h2>
<p>WebRequest是Spring Web MVC提供的统一请求访问接口，不仅仅可以访问请求相关数据（如参数区数据、请求头数据，但访问不到Cookie区数据），还可以访问会话和上下文中的数据；NativeWebRequest继承了WebRequest，并提供访问本地Servlet API的方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/webRequest"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">webRequest</span><span class="params">(WebRequest webRequest, NativeWebRequest nativeWebRequest)</span> </span>&#123;  </span><br><span class="line">   System.out.println(webRequest.getParameter(<span class="string">"test"</span>));<span class="comment">//①得到请求参数test的值  </span></span><br><span class="line">   webRequest.setAttribute(<span class="string">"name"</span>, <span class="string">"value"</span>, WebRequest.SCOPE_REQUEST);<span class="comment">//②  </span></span><br><span class="line">   System.out.println(webRequest.getAttribute(<span class="string">"name"</span>, WebRequest.SCOPE_REQUEST));  </span><br><span class="line">   HttpServletRequest request = nativeWebRequest.getNativeRequest(HttpServletRequest.class);<span class="comment">//③  </span></span><br><span class="line">   HttpServletResponse response = nativeWebRequest.getNativeResponse(HttpServletResponse.class);  </span><br><span class="line">   <span class="keyword">return</span> <span class="string">"success"</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（1）webRequest.getParameter：访问请求参数区的数据，可以通过getHeader()访问请求头数据；</p>
<p>（2）webRequest.setAttribute/getAttribute：到指定的作用范围内取/放属性数据，Servlet定义的三个作用范围分别使用如下常量代表：</p>
<ul>
<li>SCOPE_REQUEST ：代表请求作用范围；</li>
<li>SCOPE_SESSION ：代表会话作用范围；</li>
<li>SCOPE_GLOBAL_SESSION ：代表全局会话作用范围，即ServletContext上下文作用范围。</li>
</ul>
<p>（3）nativeWebRequest.getNativeRequest/nativeWebRequest.getNativeResponse：得到本地的Servlet API。</p>
<h2 id="HttpSession">HttpSession</h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/session"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">session</span><span class="params">(HttpSession session)</span> </span>&#123;  </span><br><span class="line">   System.out.println(session);  </span><br><span class="line">   <span class="keyword">return</span> <span class="string">"success"</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此处的session永远不为null。</p>
<p>注意：session访问不是线程安全的，如果需要线程安全，需要设置AnnotationMethodHandlerAdapter或RequestMappingHandlerAdapter的synchronizeOnSession属性为true，即可线程安全的访问session。</p>
<h2 id="命令对象（表单参数）默认绑定">命令对象（表单参数）默认绑定</h2>
<p>Spring Web MVC能够自动将请求参数绑定到功能处理方法的命令/表单对象上。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/commandObject"</span>, method = RequestMethod.GET)  </span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toCreateUser</span><span class="params">(HttpServletRequest request, UserModel user)</span> </span>&#123;  </span><br><span class="line">   <span class="keyword">return</span> <span class="string">"customer/create"</span>;  </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/commandObject"</span>, method = RequestMethod.POST)  </span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">createUser</span><span class="params">(HttpServletRequest request, UserModel user)</span> </span>&#123;  </span><br><span class="line">   System.out.println(user);  </span><br><span class="line">   <span class="keyword">return</span> <span class="string">"success"</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果提交的表单（包含username和password文本域），将自动将请求参数绑定到命令对象user中去。</p>
<p>注意：如果 <code>&lt;form&gt;</code> 标签中并没有设置action属性。当表单提交时，它会提交到与表单展现时相同的URL路径上。因此，可以用同一个URL，但是不同的请求类型区分表单展现和表单提交请求。表单展现时使用GET请求，表单提交时使用POST请求。</p>
<h2 id="Model、Map、ModelMap">Model、Map、ModelMap</h2>
<p>Spring Web MVC 提供Model、Map或ModelMap让我们能去暴露渲染视图需要的模型数据。三者的继承关系如下：</p>
<p><img src="https://hexo-1300861231.cos.ap-shanghai.myqcloud.com/1584800393_20200321221016375_16532.jpg" alt></p>
<p>Model实际上就是一个Map（也就是key-value对的集合），如果你希望使用非Spring类型的话，那么可以用java.util.Map来代替Model。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/model"</span>)  </span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">createUser</span><span class="params">(Model model, Map model2, ModelMap model3)</span> </span>&#123;  </span><br><span class="line">    model.addAttribute(<span class="string">"a"</span>, <span class="string">"a"</span>); </span><br><span class="line">    model2.put(<span class="string">"b"</span>, <span class="string">"b"</span>); </span><br><span class="line">    model3.put(<span class="string">"c"</span>, <span class="string">"c"</span>); </span><br><span class="line">    System.out.println(model == model2); </span><br><span class="line">    System.out.println(model2 == model3); </span><br><span class="line">    <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上面代码，虽然此处注入的是三个不同的类型（Model model, Map model2, ModelMap model3），但三者是同一个对象。因为，AnnotationMethodHandlerAdapter和RequestMappingHandlerAdapter使用BindingAwareModelMap作为模型对象的实现，即此处我们的形参（Model model, Map model2, ModelMap model3）都是同一个BindingAwareModelMap实例。</p>
<p>如果没有返回视图名称，或者也没有显式地设定模型（Model.addAttribute()方法不指定key时），如下面代码所示，仅仅返回模型数据UserModel列表。当处理器方法像这样返回对象或集合时，返回的数据会放到模型中，模型的key会根据其类型推断得出（在本例中，也就是userModelList）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/modelList"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;UserModel&gt; <span class="title">createUsers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   List&lt;UserModel&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">   list.add(<span class="keyword">new</span> UserModel(<span class="string">"jjt"</span>,<span class="string">"jiateng.jiang"</span>));</span><br><span class="line">   <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那到底哪个视图应该展示呢？此时Spring Web MVC会根据RequestToViewNameTranslator进行逻辑视图名翻译，视图名称将会根据请求路径推断得出。因为这个方法处理针对“/modelList”的请求，因此视图的名称将会是spittles（去掉开头的斜线），实际视图路径是/method/param/modelList.jsp。</p>
<h2 id="Errors、BindingResult">Errors、BindingResult</h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/error1"</span>)  </span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">error1</span><span class="params">(UserModel user, BindingResult result)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/error2"</span>)  </span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">error2</span><span class="params">(UserModel user, BindingResult result, Model model)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/error3"</span>)  </span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">error3</span><span class="params">(UserModel user, Errors errors)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码都能获取错误对象。</p>
<p>Spring3.1之前（使用AnnotationMethodHandlerAdapter）错误对象必须紧跟在命令对象/表单对象之后，如下定义是错误的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/error4"</span>)  </span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">error4</span><span class="params">(UserModel user, Model model, Errors errors)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>如上代码从Spring3.1开始（使用RequestMappingHandlerAdapter）将能正常工作，但还是推荐“错误对象紧跟在命令对象/表单对象之后”，这样是万无一失的。</p>
<h2 id="其他杂项">其他杂项</h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/other"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">other</span><span class="params">(Locale locale, Principal principal)</span></span></span><br></pre></td></tr></table></figure>
<p>java.util.Locale：得到当前请求的本地化信息，默认等价于ServletRequest.getLocale()，如果配置LocaleResolver解析器则由它决定Locale，后续介绍；</p>
<p>java.security.Principal：该主体对象包含了验证通过的用户信息，等价于HttpServletRequest.getUserPrincipal()。</p>
<h1>通过注解绑定的参数</h1>
<p>以下介绍注解方式的数据绑定。常见用于数据绑定的注释有：</p>
<p>1、@RequestParam绑定单个请求参数值；</p>
<p>2、@PathVariable绑定URI模板变量值；</p>
<p>3、@CookieValue绑定Cookie数据值</p>
<p>4、@RequestHeader绑定请求头数据；</p>
<p>5、@ModelAttribute绑定请求参数到命令对象</p>
<p>6、@SessionAttributes绑定命令对象到session；</p>
<p>7、@RequestBody绑定请求的内容区数据并能进行自动类型转换等。</p>
<p>8、@RequestPart绑定“multipart/data”数据，除了能绑定@RequestParam能做到的请求参数外，还能绑定上传的文件等。</p>
<p>除了上边提到的注解，我们还可以通过如HttpServletRequest等API得到请求数据，但推荐使用注解方式，因为使用起来更简单。</p>
<h2 id="请求参数绑定">请求参数绑定</h2>
<p>Spring MVC允许以多种方式将客户端中的数据传送到控制器的处理器方法中，包括：</p>
<ul>
<li>URL查询参数（Query Parameter）。</li>
<li>路径变量（Path Variable）。</li>
<li>表单参数（Form Parameter）。</li>
</ul>
<p>你将会看到如何编写控制器处理这些不同机制的输入。</p>
<h3 id="RequestParam绑定单个请求Url查询参数值">@RequestParam绑定单个请求Url查询参数值</h3>
<p>@RequestParam用于将请求参数区数据映射到功能处理方法的参数上。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/requestparam1"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">requestparam1</span><span class="params">(@RequestParam String username)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>请求中包含username参数（如/requestparam1?username=zhang），则自动传入。</p>
<p><strong>1.主要属性</strong></p>
<p>我们看一下@RequestParam注解主要有哪些属性：</p>
<ul>
<li>value：参数名字，即入参的请求参数名字，如username表示请求的参数区中的名字为username的参数的值将传入；</li>
<li>required：是否必须，默认是true，表示请求中一定要有相应的参数，否则将报404错误码；</li>
<li>defaultValue：默认值，表示如果请求中没有同名参数时的默认值，<strong>默认值可以是SpEL表达式，如“#{systemProperties[‘java.vm.version’]}”。</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/requestparam4"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">requestparam4</span><span class="params">(@RequestParam(value=<span class="string">"username"</span>,required=<span class="keyword">false</span>)</span> String username) </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>表示请求中可以没有名字为username的参数，如果没有默认为null，此处需要注意如下几点：</p>
<ul>
<li>原子类型：必须有值，否则抛出异常，如果允许空值请使用包装类代替。</li>
<li>Boolean包装类型类型：默认Boolean.FALSE，其他引用类型默认为null。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/requestparam5"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">requestparam5</span><span class="params">(@RequestParam(value=<span class="string">"username"</span>, required=<span class="keyword">true</span>, defaultValue=<span class="string">"zhang"</span>)</span> String username)</span></span><br></pre></td></tr></table></figure>
<p>表示如果请求中没有名字为username的参数，默认值为“zhang”。</p>
<p><strong>2.多参数值处理</strong></p>
<p>如果请求中有多个同名的应该如何接收呢？如给用户授权时，可能授予多个权限，首先看下如下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/requestparam6"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">requestparam6</span><span class="params">(@RequestParam(value=<span class="string">"role"</span>)</span> String roleList) </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>如果请求参数类似于url?role=admin&amp;role=user，则实际roleList参数入参的数据为“admin,user”，即多个数据之间使用“,”分割。</p>
<p>另外，我们应该使用如下方式来接收多个请求参数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/requestparam7"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">requestparam7</span><span class="params">(@RequestParam(value=<span class="string">"role"</span>)</span> String[] roleList) </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>或</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/requestparam8"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">requestparam8</span><span class="params">(@RequestParam(value=<span class="string">"list"</span>)</span> List&lt;String&gt; list) </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p><strong>3.编译问题（parameter name information not found）</strong></p>
<p>特别注意：右击项目，选择“属性”，打开“属性对话框”，选择“Java Compiler”然后再打开的选项卡将“Add variable attributes to generated class files”取消勾选，意思是不将局部变量信息添加到类文件中，如下图所示：</p>
<p><img src="https://hexo-1300861231.cos.ap-shanghai.myqcloud.com/1584800392_20200321221016165_28128.jpg" alt></p>
<p>当你在浏览器输入URL，如“requestparam1?username=123”时会报如下错误：</p>
<p>Name for argument type [java.lang.String] not available, and parameter name information not found in class file either.</p>
<p>表示得不到功能处理方法的参数名，此时我们需要如下方法进行入参：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/requestparam2"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">requestparam2</span><span class="params">(@RequestParam(<span class="string">"username"</span>)</span> String username)</span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>即通过@RequestParam(“username”)明确告诉Spring Web MVC使用username进行入参。</p>
<h3 id="PathVariable绑定URI路径参数">@PathVariable绑定URI路径参数</h3>
<p>@PathVariable用于将请求URL中的模板变量映射到功能处理方法的参数上。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value=<span class="string">"/users/&#123;userId&#125;/topics/&#123;topicId&#125;"</span>)  </span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">(@PathVariable(value=<span class="string">"userId"</span>)</span> <span class="keyword">int</span> userId, @<span class="title">PathVariable</span><span class="params">(value=<span class="string">"topicId"</span>)</span> <span class="keyword">int</span> topicId) </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>如请求的URL为“控制器URL/users/123/topics/456”，则自动将URL中模板变量{userId}和{topicId}绑定到通过@PathVariable注解的同名参数上，即入参后userId=123、topicId=456。代码在PathVariableTypeController中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.javass.chapter6.web.controller.paramtype;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.PathVariable;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/method/param/annotation"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PathVariableTypeController</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">   <span class="meta">@RequestMapping</span>(value=<span class="string">"/users/&#123;userId&#125;/topics/&#123;topicId&#125;"</span>)</span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">           @PathVariable(value=<span class="string">"userId"</span>)</span> <span class="keyword">int</span> userId,</span></span><br><span class="line"><span class="function">           @<span class="title">PathVariable</span><span class="params">(value=<span class="string">"topicId"</span>)</span> <span class="keyword">int</span> topicId) </span>&#123;</span><br><span class="line">       </span><br><span class="line">       System.out.println(userId + <span class="string">", "</span> + topicId);</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ModelAttribute绑定至模型对象">@ModelAttribute绑定至模型对象</h3>
<p>@ModelAttribute具有如下作用：</p>
<p><strong>（1）绑定请求参数到命令对象</strong>：放在功能处理方法的入参上时，用于将多个请求参数绑定到一个命令对象，从而简化绑定流程，而且会<strong>自动暴露为模型数据</strong>用于视图页面展示时使用；</p>
<p>如用户登录，我们需要捕获用户登录的请求参数（用户名、密码）并封装为用户对象，此时我们可以使用@ModelAttribute绑定多个请求参数到我们的命令对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value=<span class="string">"/model1"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">test1</span><span class="params">(@ModelAttribute(<span class="string">"user"</span>)</span> UserModel user)</span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>和上面“命令对象（表单参数）默认绑定”功能一样。只是此处多了一个注解@ModelAttribute(“user”)，它的作用是将该绑定的命令对象以“user”为名称添加到模型对象中供视图页面展示使用。我们此时可以在视图页面使用${user.username}来获取绑定的命令对象的属性。</p>
<p>绑定请求参数到命令对象支持对象图导航式的绑定，如请求参数包含“?username=zhang&amp;password=123&amp;workInfo.city=bj”自动绑定到user中的workInfo属性的city属性中。</p>
<p>此外，<strong>URI模板变量也能自动绑定到命令对象中</strong>，如下示例中URI模板中的wang会自动绑定到命令对象的username字段上。并且当URI模板变量和请求参数同名时，URI模板变量具有高优先权。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//URI模板：http://localhost:9080/springmvc-chapter6/method/param/annotation/model2/wang</span></span><br><span class="line"><span class="comment">//?username=zhang&amp;bool=yes&amp;schooInfo.specialty=computer</span></span><br><span class="line"><span class="comment">//&amp;hobbyList[0]=program&amp;hobbyList[1]=music&amp;map[key1]=value1&amp;map[key2]=value2&amp;state=blocked</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(value=<span class="string">"/model2/&#123;username&#125;"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">test2</span><span class="params">(@ModelAttribute(<span class="string">"model"</span>)</span> DataBinderTestModel model) </span>&#123;</span><br><span class="line">   System.out.println(model);</span><br><span class="line">   <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>（2）创建模型数据作为表单引用对象</strong>：放在处理器的一般方法（非功能处理方法）上时，是为要展示的表单准备引用对象，如注册时需要选择的所在城市等，<strong>而且在执行功能处理方法（@RequestMapping注解的方法）之前，自动添加到模型对象中，用于视图页面展示时使用</strong>；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ModelAttribute</span>(<span class="string">"cityList"</span>)  </span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">cityList</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">   <span class="keyword">return</span> Arrays.asList(<span class="string">"北京"</span>, <span class="string">"山东"</span>);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上代码会在执行功能处理方法之前执行，并将其自动添加到模型对象中，在功能处理方法中调用Model入参的containsAttribute(“cityList”)将会返回true。</p>
<p>下面两段代码中①和②有同名的命令对象，那Spring Web MVC内部如何处理的呢：</p>
<p>1、首先执行@ModelAttribute注解的方法，准备视图展示时所需要的模型数据。@ModelAttribute注解方法形式参数规则和@RequestMapping规则一样，如可以有@RequestParam等；</p>
<p>2、执行@RequestMapping注解方法，进行模型绑定时首先查找模型数据中是否含有同名对象，如果有直接使用，如果没有通过反射创建一个，因此②处的user将使用①处返回的命令对象。即②处的user等于①处的user。</p>
<p>此外，<strong>在执行@ModelAttribute注解的普通方法准备表单引用数据时，如果此时模型数据中已包含同名数据，则该方法不会执行只会引用原数据。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ModelAttribute</span>(<span class="string">"user"</span>)  <span class="comment">//①  </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> UserModel <span class="title">getUser</span><span class="params">(@RequestParam(value=<span class="string">"username"</span>, defaultValue=<span class="string">""</span>)</span> String username) </span>&#123;  </span><br><span class="line">   <span class="comment">//TODO 去数据库根据用户名查找用户对象  </span></span><br><span class="line">   UserModel user = <span class="keyword">new</span> UserModel();  </span><br><span class="line">   user.setRealname(<span class="string">"zhang"</span>);  </span><br><span class="line">   <span class="keyword">return</span> user;  </span><br><span class="line">&#125;  </span><br><span class="line"> </span><br><span class="line"><span class="meta">@RequestMapping</span>(value=<span class="string">"/model1"</span>) <span class="comment">//② 此处的user将使用①处返回的命令对象</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">test1</span><span class="params">(@ModelAttribute(<span class="string">"user"</span>)</span> UserModel user, Model model) </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p><strong>（3）暴露@RequestMapping方法的返回值作为模型数据</strong>：放在功能处理方法的返回值上时，是暴露功能处理方法的返回值作为模型数据，用于视图页面展示时使用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value=<span class="string">"/model3"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@ModelAttribute</span>(<span class="string">"user2"</span>) <span class="function">UserModel <span class="title">test3</span><span class="params">(@ModelAttribute(<span class="string">"user2"</span>)</span> UserModel user) </span>&#123;</span><br><span class="line">   UserModel user2 = <span class="keyword">new</span> UserModel();</span><br><span class="line">   user2.setUsername(<span class="string">"zhang"</span>);</span><br><span class="line">   <span class="keyword">return</span> user2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>大家可以看到返回值类型是命令对象类型，而且通过@ModelAttribute(“user2”)注解，此时会暴露返回值到模型数据（名字为user2）中供视图展示使用。</p>
<p>那到底哪个视图应该展示呢？此时Spring Web MVC会根据RequestToViewNameTranslator进行逻辑视图名翻译，视图名称将会根据请求路径推断得出。</p>
<p>此时又有问题了，@RequestMapping注解方法的入参user暴露到模型数据中的名字也是user2，其实我们能猜到：<strong>@ModelAttribute注解的返回值会覆盖@RequestMapping注解方法中的@ModelAttribute注解的同名命令对象。</strong></p>
<p><strong>（4）匿名绑定命令参数</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value=<span class="string">"/model4"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">test4</span><span class="params">(@ModelAttribute UserModel user, Model model)</span> </span>&#123;</span><br><span class="line">   System.out.println(model.containsAttribute(<span class="string">"userModel"</span>));</span><br><span class="line">   <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value=<span class="string">"/model5"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">test5</span><span class="params">(UserModel user, Model model)</span> </span>&#123;</span><br><span class="line">   System.out.println(model.containsAttribute(<span class="string">"userModel"</span>));</span><br><span class="line">   <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时我们没有为命令对象提供暴露到模型数据中的名字，此时的名字是什么呢？Spring Web MVC自动将简单类名（首字母小写）作为名字暴露，如“cn.javass.chapter6.model.UserModel”暴露的名字为“userModel”。</p>
<p>对于集合类型（Collection接口的实现者们，包括数组），生成的模型对象属性名为“简单类名（首字母小写）”+“List”，如<code>List&lt;String&gt;</code> 生成的模型对象属性名为“stringList”，<code>List&lt;UserModel&gt;</code> 生成的模型对象属性名为“userModelList”。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value=<span class="string">"/model6"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@ModelAttribute</span> <span class="function">List&lt;String&gt; <span class="title">test6</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> Arrays.asList(<span class="string">"山东"</span>, <span class="string">"北京"</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@RequestMapping</span>(value=<span class="string">"/model7"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@ModelAttribute</span> <span class="function">List&lt;UserModel&gt; <span class="title">test7</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> Arrays.asList(<span class="keyword">new</span> UserModel(), <span class="keyword">new</span> UserModel());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其他情况一律都是使用简单类名（首字母小写）作为模型对象属性名，如<code>Map&lt;String, UserModel&gt;</code> 类型的模型对象属性名为“map”。</p>
<h2 id="CookieValue绑定Cookie数据值">@CookieValue绑定Cookie数据值</h2>
<p>@CookieValue用于将请求的Cookie数据映射到功能处理方法的参数上。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value=<span class="string">"/cookie"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">(@CookieValue(value=<span class="string">"JSESSIONID"</span>, defaultValue=<span class="string">""</span>)</span> String sessionId) </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>如上配置将自动将JSESSIONID值入参到sessionId参数上，defaultValue表示Cookie中没有JSESSIONID时默认为空。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value=<span class="string">"/cookie2"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">test2</span><span class="params">(@CookieValue(value=<span class="string">"JSESSIONID"</span>, defaultValue=<span class="string">""</span>)</span> Cookie sessionId) </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>传入参数类型也可以是javax.servlet.http.Cookie类型。</p>
<p><strong>@CookieValue也拥有和@RequestParam相同的三个参数，含义一样。</strong></p>
<h2 id="RequestHeader绑定请求头数据">@RequestHeader绑定请求头数据</h2>
<p>@RequestHeader用于将请求的头信息区数据映射到功能处理方法的参数上。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value=<span class="string">"/header"</span>)  </span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">(@RequestHeader(<span class="string">"User-Agent"</span>)</span> String userAgent, @<span class="title">RequestHeader</span><span class="params">(value=<span class="string">"Accept"</span>)</span> String[] accepts) </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>如上配置将自动将请求头“User-Agent”值入参到userAgent参数上，并将“Accept”请求头值入参到accepts参数上。测试代码在HeaderValueTypeController中。</p>
<p><strong>@RequestHeader也拥有和@RequestParam相同的三个参数，含义一样。</strong></p>
<h2 id="SessionAttributes绑定命令对象到session">@SessionAttributes绑定命令对象到session</h2>
<p>有时候我们需要在多次请求之间保持数据，一般情况需要我们明确的调用HttpSession的API来存取会话数据，如多步骤提交的表单。Spring Web MVC提供了@SessionAttributes进行请求间透明的存取会话数据。</p>
<p>示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/method/param/annotation"</span>)</span><br><span class="line"><span class="comment">//1、在控制器类头上添加@SessionAttributes注解  </span></span><br><span class="line"><span class="meta">@SessionAttributes</span>(value = &#123;<span class="string">"user"</span>&#125;, types=&#123;&#125;)    <span class="comment">//① 标识模型对象中名字如果是“user”，将存储在会话范围，并自动暴露到模型数据中</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SessionAttributeController</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">//2、@ModelAttribute注解的方法进行表单引用对象的创建</span></span><br><span class="line">   <span class="meta">@ModelAttribute</span>(<span class="string">"user"</span>)    <span class="comment">//② 如果模型数据中没有名字为user的对象，调用该方法并存储到模型数据中</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> UserModel <span class="title">initUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> UserModel();</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">//3、@RequestMapping注解方法的@ModelAttribute注解的参数进行命令对象的绑定</span></span><br><span class="line">   <span class="meta">@RequestMapping</span>(<span class="string">"/session1"</span>)   <span class="comment">//③ 首先查找模型数据中是否有user对象，有直接使用，没有则创建一个，并将请求参数绑定到该对象上</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">session1</span><span class="params">(@ModelAttribute(<span class="string">"user"</span>)</span> UserModel user, ModelMap model, WebRequest request, SessionStatus status) </span>&#123;</span><br><span class="line">       System.out.println(user == model.get(<span class="string">"user"</span>));</span><br><span class="line">       user.setUsername(<span class="string">"zhang"</span>);</span><br><span class="line">       <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">//4、通过SessionStatus的setComplete()方法清除@SessionAttributes指定的会话数据</span></span><br><span class="line">   <span class="meta">@RequestMapping</span>(<span class="string">"/session2"</span>)   <span class="comment">//③</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">session</span><span class="params">(@ModelAttribute(<span class="string">"user"</span>)</span> UserModel user, ModelMap model, WebRequest request, SessionStatus status) </span>&#123;</span><br><span class="line">       System.out.println(user == request.getAttribute(<span class="string">"user"</span>, WebRequest.SCOPE_SESSION));</span><br><span class="line">       System.out.println(user == model.get(<span class="string">"user"</span>));</span><br><span class="line">       System.out.println(user);</span><br><span class="line">       <span class="keyword">if</span>(<span class="keyword">true</span>) &#123; <span class="comment">//④如果会话可以终止了，就标识会话结束，可以清理掉会话数据了</span></span><br><span class="line">           status.setComplete();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>@SessionAttributes(value = {“user”}) 标识将模型数据中的名字为“user” 的对象存储到会话中（默认HttpSession），此处value指定将模型数据中的哪些数据（名字进行匹配）存储到会话中，此外还有一个types属性表示模型数据中的哪些类型的对象存储到会话范围内，如果同时指定value和types属性则那些名字和类型都匹配的对象才能存储到会话范围内。</p>
<p>另外，多步骤提交表单需要考虑会话超时问题，这种方式可能对用户不太友好，我们可以采取隐藏表单（即当前步骤将其他步骤的表单隐藏）或表单数据存数据库（每步骤更新下数据库数据）等方案解决。</p>
<h3 id="包含-SessionAttributes的模型数据处理流程">包含@SessionAttributes的模型数据处理流程</h3>
<p>根据示例代码分析：</p>
<p>1、 首先根据@SessionAttributes注解信息查找会话内的对象放入到模型数据中；</p>
<p>2、执行@ModelAttribute注解的方法：<strong>如果模型数据中包含同名的数据，则不执行@ModelAttribute注解方法来准备表单引用数据，而是使用①步骤中的会话数据</strong>；如果模型数据中不包含同名的数据，执行@ModelAttribute注解的方法并将返回值添加到模型数据中；</p>
<p>3、执行@RequestMapping方法，绑定@ModelAttribute注解的参数：查找模型数据中是否有@ModelAttribute注解的同名对象，如果有直接使用，否则通过反射创建一个；并将请求参数绑定到该命令对象；</p>
<p>此处需要注意：如果使用@SessionAttributes注解控制器类之后，③步骤一定是从模型对象中取得同名的命令对象，如果模型数据中不存在将抛出HttpSessionRequiredException Expected session attribute ‘user’(Spring3.1)</p>
<p>或HttpSessionRequiredException Session attribute ‘user’ required - not found in session(Spring3.0)异常。</p>
<p>4、如果会话可以销毁了，如多步骤提交表单的最后一步，此时可以调用SessionStatus对象的setComplete()标识当前会话的@SessionAttributes指定的数据可以清理了，此时当@RequestMapping功能处理方法执行完毕后会进行清理会话数据。</p>
<h3 id="源代码验证">源代码验证</h3>
<p>此处我们分析的是Spring3.1的RequestMappingHandlerAdapter，读者可以自行验证Spring3.0的AnnotationMethodHandlerAdapter，流程一样：</p>
<p>1、RequestMappingHandlerAdapter.invokeHandlerMethod</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1、RequestMappingHandlerAdapter首先调用ModelFactory的initModel方法准备模型数据：  </span></span><br><span class="line">modelFactory.initModel(webRequest, mavContainer, requestMappingMethod);  </span><br><span class="line"><span class="comment">//2、调用@RequestMapping注解的功能处理方法  </span></span><br><span class="line">requestMappingMethod.invokeAndHandle(webRequest, mavContainer);  </span><br><span class="line"><span class="comment">//3、更新/合并模型数据  </span></span><br><span class="line">modelFactory.updateModel(webRequest, mavContainer);</span><br></pre></td></tr></table></figure>
<p>2、ModelFactory.initModel</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, ?&gt; attributesInSession = <span class="keyword">this</span>.sessionAttributesHandler.retrieveAttributes(request);  </span><br><span class="line"><span class="comment">//1.1、将与@SessionAttributes注解相关的会话对象放入模型数据中  </span></span><br><span class="line">mavContainer.mergeAttributes(attributesInSession);  </span><br><span class="line"><span class="comment">//1.2、调用@ModelAttribute方法添加表单引用对象  </span></span><br><span class="line">invokeModelAttributeMethods(request, mavContainer);  </span><br><span class="line"><span class="comment">//1.3、验证模型数据中是否包含@SessionAttributes注解相关的会话对象，不包含抛出异常  </span></span><br><span class="line"><span class="keyword">for</span> (String name : findSessionAttributeArguments(handlerMethod)) &#123;  </span><br><span class="line">   <span class="keyword">if</span> (!mavContainer.containsAttribute(name)) &#123;  </span><br><span class="line">       <span class="comment">//1.4、此处防止在@ModelAttribute注解方法又添加了会话对象  </span></span><br><span class="line">       <span class="comment">//如在@ModelAttribute注解方法调用session.setAttribute("user", new UserModel());  </span></span><br><span class="line">       Object value = <span class="keyword">this</span>.sessionAttributesHandler.retrieveAttribute(request, name);  </span><br><span class="line">       <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;  </span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> HttpSessionRequiredException(<span class="string">"Expected session attribute '"</span> + name + <span class="string">"'"</span>);  </span><br><span class="line">       &#125;  </span><br><span class="line">       mavContainer.addAttribute(name, value);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3、ModelFactory.invokeModelAttributeMethods</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (InvocableHandlerMethod attrMethod : <span class="keyword">this</span>.attributeMethods) &#123;  </span><br><span class="line">   String modelName = attrMethod.getMethodAnnotation(ModelAttribute.class).value();   </span><br><span class="line">   <span class="comment">//1.2.1、如果模型数据中包含同名数据则不再添加  </span></span><br><span class="line">   <span class="keyword">if</span> (mavContainer.containsAttribute(modelName)) &#123;  </span><br><span class="line">       <span class="keyword">continue</span>;  </span><br><span class="line">   &#125;  </span><br><span class="line">   <span class="comment">//1.2.2、调用@ModelAttribute注解方法并将返回值添加到模型数据中，此处省略实现代码  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>4、requestMappingMethod.invokeAndHandle 调用功能处理方法，此处省略</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//3.1、如果会话被标识为完成，此时从会话中清除@SessionAttributes注解相关的会话对象  </span></span><br><span class="line"><span class="keyword">if</span> (mavContainer.getSessionStatus().isComplete())&#123;   </span><br><span class="line">   <span class="keyword">this</span>.sessionAttributesHandler.cleanupAttributes(request);  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">//3.2、如果会话没有完成，将模型数据中的@SessionAttributes注解相关的对象添加到会话中  </span></span><br><span class="line"><span class="keyword">else</span> &#123;  </span><br><span class="line">   <span class="keyword">this</span>.sessionAttributesHandler.storeAttributes(request, mavContainer.getModel());  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">//省略部分代码  </span></span><br><span class="line"><span class="comment">//3.2、如果会话没有完成，将模型数据中的@SessionAttributes注解相关的对象添加到会话中</span></span><br></pre></td></tr></table></figure>
<h2 id="Value绑定SpEL表示式">@Value绑定SpEL表示式</h2>
<p>@Value用于将一个SpEL表达式结果映射到到功能处理方法的参数上。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value=<span class="string">"/value"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">(@Value(<span class="string">"#&#123;systemProperties['java.vm.version']&#125;"</span>)</span> String jvmVersion) </span>&#123;</span><br><span class="line">    System.out.println(jvmVersion);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      </div>
      
      
      
    </div>
    
  <ul class="breadcrumb">
          
            <li><a href="/quotes/">QUOTES</a></li>
            <li><a href="/quotes/Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">SPRING学习笔记</a></li>
            <li>24-功能处理方法参数绑定</li>
          
  </ul>

    
    
    
  </div>


          </div>
          

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#null"><span class="nav-text">默认自动绑定的参数</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Request和Response"><span class="nav-text">Request和Response</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#InputStream、OutputStream或Reader、Writer"><span class="nav-text">InputStream、OutputStream或Reader、Writer</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#WebRequest、NativeWebRequest"><span class="nav-text">WebRequest、NativeWebRequest</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HttpSession"><span class="nav-text">HttpSession</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#命令对象（表单参数）默认绑定"><span class="nav-text">命令对象（表单参数）默认绑定</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Model、Map、ModelMap"><span class="nav-text">Model、Map、ModelMap</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Errors、BindingResult"><span class="nav-text">Errors、BindingResult</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#其他杂项"><span class="nav-text">其他杂项</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#null"><span class="nav-text">通过注解绑定的参数</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#请求参数绑定"><span class="nav-text">请求参数绑定</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#RequestParam绑定单个请求Url查询参数值"><span class="nav-text">@RequestParam绑定单个请求Url查询参数值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#PathVariable绑定URI路径参数"><span class="nav-text">@PathVariable绑定URI路径参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ModelAttribute绑定至模型对象"><span class="nav-text">@ModelAttribute绑定至模型对象</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CookieValue绑定Cookie数据值"><span class="nav-text">@CookieValue绑定Cookie数据值</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RequestHeader绑定请求头数据"><span class="nav-text">@RequestHeader绑定请求头数据</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SessionAttributes绑定命令对象到session"><span class="nav-text">@SessionAttributes绑定命令对象到session</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#包含-SessionAttributes的模型数据处理流程"><span class="nav-text">包含@SessionAttributes的模型数据处理流程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#源代码验证"><span class="nav-text">源代码验证</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Value绑定SpEL表示式"><span class="nav-text">@Value绑定SpEL表示式</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <img class="site-author-image" itemprop="image" alt="jiateng.jiang"
    src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">jiateng.jiang</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">44</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">32</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">jiateng.jiang</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v4.0.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.4.2
  </div>

        












        
      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/pisces.js"></script>
<script src="/js/next-boot.js"></script>



  






  <script src="/js/local-search.js"></script>








<script>
if (document.querySelectorAll('div.pdf').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/pdfobject@2/pdfobject.min.js', () => {
    document.querySelectorAll('div.pdf').forEach(element => {
      PDFObject.embed(element.getAttribute('target'), element, {
        pdfOpenParams: {
          navpanes: 0,
          toolbar: 0,
          statusbar: 0,
          pagemode: 'thumbs',
          view: 'FitH'
        },
        PDFJS_URL: '/lib/pdf/web/viewer.html',
        height: element.getAttribute('height') || '100%'
      });
    });
  }, window.PDFObject);
}
</script>





  

  

  

</body>
</html>
