<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '7.4.2',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: true,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"manual","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.json',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    },
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="在前面的一些章中，你看到了如何使用RMI、Hessian、Burlap、HTTP invoker和Web服务在应用程序之间进行通信。所有这些通信机制都是同步的，客户端应用程序直接与远程服务相交互，并且一直等到远程过程完成后才继续执行。同步通信有它自己的适用场景。不过，对于开发者而言，这种通信方式并不是应用程序之间进行交互的唯一方式。 异步消息 是一个应用程序向另一个应用程序间接发送消息的一种方式，">
<meta property="og:type" content="website">
<meta property="og:title" content="JJT-个人Wiki">
<meta property="og:url" content="https:&#x2F;&#x2F;hexo-pages-1300861231.cos-website.ap-shanghai.myqcloud.com&#x2F;quotes&#x2F;Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0&#x2F;51-Spring%E6%B6%88%E6%81%AF.html">
<meta property="og:site_name" content="JJT-个人Wiki">
<meta property="og:description" content="在前面的一些章中，你看到了如何使用RMI、Hessian、Burlap、HTTP invoker和Web服务在应用程序之间进行通信。所有这些通信机制都是同步的，客户端应用程序直接与远程服务相交互，并且一直等到远程过程完成后才继续执行。同步通信有它自己的适用场景。不过，对于开发者而言，这种通信方式并不是应用程序之间进行交互的唯一方式。 异步消息 是一个应用程序向另一个应用程序间接发送消息的一种方式，">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https:&#x2F;&#x2F;hexo-1300861231.cos.ap-shanghai.myqcloud.com&#x2F;1584859092_20200322142654317_6957.png">
<meta property="og:image" content="https:&#x2F;&#x2F;hexo-1300861231.cos.ap-shanghai.myqcloud.com&#x2F;1584859092_20200322142654100_27885.png">
<meta property="og:image" content="https:&#x2F;&#x2F;hexo-1300861231.cos.ap-shanghai.myqcloud.com&#x2F;1584859092_20200322142653782_12064.png">
<meta property="og:image" content="https:&#x2F;&#x2F;hexo-1300861231.cos.ap-shanghai.myqcloud.com&#x2F;1584859091_20200322142653468_1760.png">
<meta property="og:image" content="https:&#x2F;&#x2F;hexo-1300861231.cos.ap-shanghai.myqcloud.com&#x2F;1584859091_20200322142653148_16948.png">
<meta property="og:image" content="https:&#x2F;&#x2F;hexo-1300861231.cos.ap-shanghai.myqcloud.com&#x2F;1584859091_20200322142652935_2752.png">
<meta property="og:image" content="https:&#x2F;&#x2F;hexo-1300861231.cos.ap-shanghai.myqcloud.com&#x2F;1584859091_20200322142652723_18427.png">
<meta property="og:image" content="https:&#x2F;&#x2F;hexo-1300861231.cos.ap-shanghai.myqcloud.com&#x2F;1584859091_20200322142652404_21625.png">
<meta property="og:image" content="https:&#x2F;&#x2F;hexo-1300861231.cos.ap-shanghai.myqcloud.com&#x2F;1584859090_20200322142652190_31273.png">
<meta property="og:image" content="https:&#x2F;&#x2F;hexo-1300861231.cos.ap-shanghai.myqcloud.com&#x2F;1584859090_20200322142651979_1024.png">
<meta property="og:image" content="https:&#x2F;&#x2F;hexo-1300861231.cos.ap-shanghai.myqcloud.com&#x2F;1584859090_20200322142651767_9769.jpg">
<meta property="og:image" content="https:&#x2F;&#x2F;hexo-1300861231.cos.ap-shanghai.myqcloud.com&#x2F;1584859090_20200322142651445_11640.jpg">
<meta property="og:image" content="https:&#x2F;&#x2F;hexo-1300861231.cos.ap-shanghai.myqcloud.com&#x2F;1584859090_20200322142650724_8086.png">
<meta property="og:image" content="https:&#x2F;&#x2F;hexo-1300861231.cos.ap-shanghai.myqcloud.com&#x2F;1584859089_20200322142650509_30217.png">
<meta property="og:image" content="https:&#x2F;&#x2F;hexo-1300861231.cos.ap-shanghai.myqcloud.com&#x2F;1584859089_20200322142650296_851.jpg">
<meta property="og:image" content="https:&#x2F;&#x2F;hexo-1300861231.cos.ap-shanghai.myqcloud.com&#x2F;1584859089_20200322142649973_28666.png">
<meta property="og:image" content="https:&#x2F;&#x2F;hexo-1300861231.cos.ap-shanghai.myqcloud.com&#x2F;1584859089_20200322142649761_31501.png">
<meta property="og:image" content="https:&#x2F;&#x2F;hexo-1300861231.cos.ap-shanghai.myqcloud.com&#x2F;1584859088_20200322142649549_14283.png">
<meta property="og:image" content="https:&#x2F;&#x2F;hexo-1300861231.cos.ap-shanghai.myqcloud.com&#x2F;1584859088_20200322142649336_12137.png">
<meta property="og:image" content="https:&#x2F;&#x2F;hexo-1300861231.cos.ap-shanghai.myqcloud.com&#x2F;1584859088_20200322142649124_30048.png">
<meta property="og:image" content="https:&#x2F;&#x2F;hexo-1300861231.cos.ap-shanghai.myqcloud.com&#x2F;1584859088_20200322142648911_7986.png">
<meta property="og:image" content="https:&#x2F;&#x2F;hexo-1300861231.cos.ap-shanghai.myqcloud.com&#x2F;1584859088_20200322142648697_18304.png">
<meta property="og:image" content="https:&#x2F;&#x2F;hexo-1300861231.cos.ap-shanghai.myqcloud.com&#x2F;1584859087_20200322142648484_13380.png">
<meta property="og:image" content="https:&#x2F;&#x2F;hexo-1300861231.cos.ap-shanghai.myqcloud.com&#x2F;1584859087_20200322142648171_5421.jpg">
<meta property="og:image" content="https:&#x2F;&#x2F;hexo-1300861231.cos.ap-shanghai.myqcloud.com&#x2F;1584859087_20200322142647955_15102.png">
<meta property="og:image" content="https:&#x2F;&#x2F;hexo-1300861231.cos.ap-shanghai.myqcloud.com&#x2F;1584859087_20200322142647643_6053.png">
<meta property="og:image" content="https:&#x2F;&#x2F;hexo-1300861231.cos.ap-shanghai.myqcloud.com&#x2F;1584859087_20200322142647427_26508.png">
<meta property="og:image" content="https:&#x2F;&#x2F;hexo-1300861231.cos.ap-shanghai.myqcloud.com&#x2F;1584859086_20200322142647211_30993.jpg">
<meta property="og:image" content="https:&#x2F;&#x2F;hexo-1300861231.cos.ap-shanghai.myqcloud.com&#x2F;1584859086_20200322142646998_25666.png">
<meta property="og:image" content="https:&#x2F;&#x2F;hexo-1300861231.cos.ap-shanghai.myqcloud.com&#x2F;1584859086_20200322142646784_28455.png">
<meta property="og:image" content="https:&#x2F;&#x2F;hexo-1300861231.cos.ap-shanghai.myqcloud.com&#x2F;1584859086_20200322142646571_3803.png">
<meta property="og:image" content="https:&#x2F;&#x2F;hexo-1300861231.cos.ap-shanghai.myqcloud.com&#x2F;1584859085_20200322142646257_5701.jpg">
<meta property="og:image" content="https:&#x2F;&#x2F;hexo-1300861231.cos.ap-shanghai.myqcloud.com&#x2F;1584859043_20200322142645935_7785.png">
<meta property="og:image" content="https:&#x2F;&#x2F;hexo-1300861231.cos.ap-shanghai.myqcloud.com&#x2F;1584859043_20200322142645724_20700.png">
<meta property="og:image" content="https:&#x2F;&#x2F;hexo-1300861231.cos.ap-shanghai.myqcloud.com&#x2F;1584859043_20200322142645512_31267.png">
<meta property="og:image" content="https:&#x2F;&#x2F;hexo-1300861231.cos.ap-shanghai.myqcloud.com&#x2F;1584859043_20200322142645300_24601.png">
<meta property="og:image" content="https:&#x2F;&#x2F;hexo-1300861231.cos.ap-shanghai.myqcloud.com&#x2F;1584859042_20200322142644986_8577.png">
<meta property="og:image" content="https:&#x2F;&#x2F;hexo-1300861231.cos.ap-shanghai.myqcloud.com&#x2F;1584859042_20200322142644673_7732.png">
<meta property="og:image" content="https:&#x2F;&#x2F;hexo-1300861231.cos.ap-shanghai.myqcloud.com&#x2F;1584859042_20200322142644358_14412.png">
<meta property="og:image" content="https:&#x2F;&#x2F;hexo-1300861231.cos.ap-shanghai.myqcloud.com&#x2F;1584859042_20200322142644146_1995.png">
<meta property="og:image" content="https:&#x2F;&#x2F;hexo-1300861231.cos.ap-shanghai.myqcloud.com&#x2F;1584859042_20200322142643936_9596.png">
<meta property="og:image" content="https:&#x2F;&#x2F;hexo-1300861231.cos.ap-shanghai.myqcloud.com&#x2F;1584859041_20200322142643724_26928.png">
<meta property="og:image" content="https:&#x2F;&#x2F;hexo-1300861231.cos.ap-shanghai.myqcloud.com&#x2F;1584859041_20200322142643514_18977.png">
<meta property="og:image" content="https:&#x2F;&#x2F;hexo-1300861231.cos.ap-shanghai.myqcloud.com&#x2F;1584859041_20200322142643192_23962.png">
<meta property="og:image" content="https:&#x2F;&#x2F;hexo-1300861231.cos.ap-shanghai.myqcloud.com&#x2F;1584859041_20200322142642981_13746.png">
<meta property="og:image" content="https:&#x2F;&#x2F;hexo-1300861231.cos.ap-shanghai.myqcloud.com&#x2F;1584859041_20200322142642773_10642.png">
<meta property="og:image" content="https:&#x2F;&#x2F;hexo-1300861231.cos.ap-shanghai.myqcloud.com&#x2F;1584859040_20200322142642562_30572.png">
<meta property="og:image" content="https:&#x2F;&#x2F;hexo-1300861231.cos.ap-shanghai.myqcloud.com&#x2F;1584859040_20200322142642352_10009.png">
<meta property="og:image" content="https:&#x2F;&#x2F;hexo-1300861231.cos.ap-shanghai.myqcloud.com&#x2F;1584859040_20200322142642141_20650.png">
<meta property="og:image" content="https:&#x2F;&#x2F;hexo-1300861231.cos.ap-shanghai.myqcloud.com&#x2F;1584859040_20200322142641930_18773.png">
<meta property="og:image" content="https:&#x2F;&#x2F;hexo-1300861231.cos.ap-shanghai.myqcloud.com&#x2F;1584859039_20200322142641722_10847.png">
<meta property="og:image" content="https:&#x2F;&#x2F;hexo-1300861231.cos.ap-shanghai.myqcloud.com&#x2F;1584859039_20200322142641507_32456.png">
<meta property="og:image" content="https:&#x2F;&#x2F;hexo-1300861231.cos.ap-shanghai.myqcloud.com&#x2F;1584859039_20200322142641297_22554.png">
<meta property="og:image" content="https:&#x2F;&#x2F;hexo-1300861231.cos.ap-shanghai.myqcloud.com&#x2F;1584859039_20200322142641083_15456.png">
<meta property="og:image" content="https:&#x2F;&#x2F;hexo-1300861231.cos.ap-shanghai.myqcloud.com&#x2F;1584859039_20200322142640874_30006.png">
<meta property="og:image" content="https:&#x2F;&#x2F;hexo-1300861231.cos.ap-shanghai.myqcloud.com&#x2F;1584859038_20200322142640661_4320.png">
<meta property="og:image" content="https:&#x2F;&#x2F;hexo-1300861231.cos.ap-shanghai.myqcloud.com&#x2F;1584859038_20200322142640341_5419.png">
<meta property="og:updated_time" content="2020-12-15T11:07:33.044Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https:&#x2F;&#x2F;hexo-1300861231.cos.ap-shanghai.myqcloud.com&#x2F;1584859092_20200322142654317_6957.png">

<link rel="canonical" href="https://hexo-pages-1300861231.cos-website.ap-shanghai.myqcloud.com/quotes/Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/51-Spring%E6%B6%88%E6%81%AF">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: false,
    isPage: true,
    isArchive: false
  };
</script>

  <title> | JJT-个人Wiki
  </title>
  








  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">JJT-个人Wiki</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">you see see you one day day</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="搜索..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
  
  

          <div class="content">
            

  <div class="posts-expand">
    
    
    
    <div class="post-block" lang="zh-CN">
      <header class="post-header">

<h1 class="post-title" itemprop="name headline">
</h1>

<div class="post-meta">
  
  <ul class="breadcrumb">
          
            <li><a href="/quotes/">QUOTES</a></li>
            <li><a href="/quotes/Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">SPRING学习笔记</a></li>
            <li>51-SPRING消息</li>
          
  </ul>

</div>

</header>

      
      
      
      <div class="post-body">
          <p>在前面的一些章中，你看到了如何使用RMI、Hessian、Burlap、HTTP invoker和Web服务在应用程序之间进行通信。所有这些通信机制都是同步的，客户端应用程序直接与远程服务相交互，并且一直等到远程过程完成后才继续执行。</p><p>同步通信有它自己的适用场景。不过，对于开发者而言，这种通信方式并不是应用程序之间进行交互的唯一方式。 <strong>异步消息</strong> 是一个应用程序向另一个应用程序间接发送消息的一种方式，这种方式无需等待对方的响应。相对于同步消息，异步消息具有多个优势，关于这一点你很快就会看到。</p><a id="more"></a>

<p>借助Spring，我们有多个实现异步消息的可选方案。在本章中，我们将会看到如何在Spring中使用Java消息服务（Java Message Service，JMS）和高级消息队列协议（Advanced Message Queuing Protocol，AMQP）发送和接收消息。除了基本的消息发送和接收之外，我们还会看到Spring对消息驱动POJO的支持，它是一种与EJB的消息驱动Bean（message-driven bean，MDB）类似的消息接收方式。</p>
<h1>异步消息简介</h1>
<p>与前面几章中介绍的远程调用机制以及REST接口类似，异步消息也是用于应用程序之间通信的。但是，在系统之间传递信息的方式上，它与其他机制有所不同。</p>
<p>像RMI和Hessian/Burlap这样的远程调用机制是同步的。如下图所示，当客户端调用远程方法时，客户端必须等到远程方法完成后，才能继续执行。即使远程方法不向客户端返回任何信息，客户端也要被阻塞直到服务完成。</p>
<p><img src="https://hexo-1300861231.cos.ap-shanghai.myqcloud.com/1584859092_20200322142654317_6957.png" alt></p>
<p>消息则是异步发送的，如下图所示，客户端不需要等待服务处理消息，甚至不需要等待消息投递完成。客户端发送消息，然后继续执行，这是因为客户端假定服务最终可以收到并处理这条消息。</p>
<p><img src="https://hexo-1300861231.cos.ap-shanghai.myqcloud.com/1584859092_20200322142654100_27885.png" alt></p>
<p>相对于同步通信，异步通信具有多项优势，我们很快就会看到这些优点。但是首先，让我们看看如何异步发送消息。</p>
<h2 id="发送消息">发送消息</h2>
<p>大多数人都使用过邮政服务。每天会有数百万信件、明信片和包裹交到邮递员手上，我们相信自己邮寄的东西会被送到目的地。世界实在是太大了，我们无法自己去运送这些东西，因此我们依赖邮政系统为我们运送。我们在信封上写明地址，贴张邮票，接着把它们投到信箱里，而不需要考虑信件如何到达目的地。</p>
<p>邮政服务的关键在于间接性。当奶奶的生日到来时，如果我们直接送给她一张贺卡，这非常不方便。我们必须留出几小时甚至是几天的时间去为她送生日贺卡，这取决于她住哪里。幸运的是，邮局可以将贺卡送到奶奶那里，而我们可以继续自己的生活。</p>
<p>与此类似，间接性也是异步消息的关键所在。当一个应用向另一个应用发送消息时，两个应用之间没有直接的联系。相反的是，发送方的应用程序会将消息交给一个服务，由服务确保将消息投递给接收方应用程序。</p>
<p>在异步消息中有两个主要的概念： <strong>消息代理</strong> （message broker）和 <strong>目的地</strong> （destination）。当一个应用发送消息时，会将消息交给一个消息代理。消息代理实际上类似于邮局。消息代理可以确保消息被投递到指定的目的地，同时解放发送者，使其能够继续进行其他的业务。</p>
<p>当我们通过邮局邮递信件时，最重要的是要写上地址，这样邮局就可以知道这封信应该被投递到哪里。与此类似，每条异步消息都带有一个目的地，目的地就好像一个邮箱，可以将消息放入这个邮箱，直到有人将它们取走。</p>
<p>但是，并不像信件地址那样必须标识特定的收件人或街道地址，消息中的目的地相对来说并不那么具体。目的地只关注消息应该从 <strong>哪里</strong> 获得——而不关心是由 <strong>谁</strong> 取走消息的。这种情况下，目的地就如同信件的地址为“本地居民”。</p>
<p>尽管不同的消息系统会提供不同的消息路由模式，但是有两种通用的目的地： <strong>队列（queue）和主题（topic）</strong> 。每种类型都与特定的消息模型相关联，分别是点对点模型（队列）和发布/订阅模型（主题）。</p>
<h2 id="点对点消息模型">点对点消息模型</h2>
<p>在点对点模型中，每一条消息都有一个发送者和一个接收者，如下图所示。当消息代理得到消息时，它将消息放入一个队列中。当接收者请求队列中的下一条消息时，消息会从队列中取出，并投递给接收者。因为消息投递后会从队列中删除，这样就可以保证消息只能投递给一个接收者。消息队列对消息发送者和消息接收者进行了解耦。</p>
<p><img src="https://hexo-1300861231.cos.ap-shanghai.myqcloud.com/1584859092_20200322142653782_12064.png" alt></p>
<p>尽管消息队列中的每一条消息只被投递给一个接收者，但是并不意味着只能使用一个接收者从队列中获取消息。事实上，通常可以使用几个接收者来处理队列中的消息。不过，每个接收者都会处理自己所接收到的消息。</p>
<p>这与在银行排队等候类似。在等待时，我们可能注意到很多银行柜员都可以帮助我们处理金融业务。在柜员帮助客户完成业务后，她就空闲了，此时，她会要求排队等候的下一个人前来办理业务。如果我们排在队伍的最前边时，我们就会被叫到，然后由其中的一个空闲柜员来帮助我们处理业务，而其他的柜员则会帮助其他的银行客户。</p>
<p>从另一个角度看，我们在银行排队（队列）时，并不知道哪一个柜员（接收者）会帮助我们办理业务。我们可以计算队伍中有多少人，与柜员的数目进行比较，注意哪一个柜员业务办理速度最快，然后猜测会由哪一个柜员办理我们的业务。但是，一般情况下我们都会猜错，最终会由另一个柜员来办理。</p>
<p>同样，在点对点的消息中，如果有多个接收者监听队列，我们也无法知道某条特定的消息会由哪一个接收者处理。这种不确定性实际上有很多好处，因为我们只需要简单地为队列添加新的监听器就能提高应用的消息处理能力。</p>
<h2 id="发布—订阅消息模型">发布—订阅消息模型</h2>
<p>在发布—订阅消息模型中，消息会发送给一个主题。与队列类似，多个接收者都可以监听一个主题。但是， <strong>与队列不同的是，消息不再是只投递给一个接收者，而是主题的所有订阅者都会接收到此消息的副本</strong> ，如下图所示。</p>
<p><img src="https://hexo-1300861231.cos.ap-shanghai.myqcloud.com/1584859091_20200322142653468_1760.png" alt></p>
<p>正如它的名字所暗示的，发布—订阅消息模型与杂志发行商和杂志订阅者很相似。杂志（消息）出版后，发送给邮局，然后所有的订阅者都会收到杂志的副本。</p>
<p>杂志的类比就到此为至，因为对于异步消息来讲，发布者并不知道谁订阅了它的消息。发布者只知道它的消息要发送到一个特定的主题——而不知道有谁在监听这个主题。也就是说，发布者并不知道消息是如何被处理的。</p>
<p>现在，我们已经介绍了异步消息的基本概念，下面让我们看看它与同步RPC的对比。</p>
<h2 id="评估异步消息的优点">评估异步消息的优点</h2>
<p>虽然同步通信比较容易理解，建立起来也很简单，但是采用同步通信机制访问远程服务的客户端存在几个限制，最主要的是：</p>
<ul>
<li>同步通信意味着等待。当客户端调用远程服务的方法时，它必须等待远程方法结束后才能继续执行。如果客户端与远程服务频繁通信，或者远程服务响应很慢，就会对客户端应用的性能带来负面影响。</li>
<li>客户端通过服务接口与远程服务相耦合。如果服务的接口发生变化，此服务的所有客户端都需要做相应的改变。</li>
<li>客户端与远程服务的位置耦合。客户端必须配置服务的网络位置，这样它才知道如何与远程服务进行交互。如果网络拓扑进行调整，客户端也需要重新配置新的网络位置。</li>
<li>客户端与服务的可用性相耦合。如果远程服务不可用，客户端实际上也无法正常运行。</li>
</ul>
<p>虽然同步通信仍然有它的适用场景，但是在决定应用程序更适合哪种通信机制时，我们必须考量以上的这些缺点。如果这些限制正是你所担心的，那你可能很想知道异步通信是如何解决这些问题的。</p>
<h3 id="无需等待">无需等待</h3>
<p>当使用JMS发送消息时，客户端不必等待消息被处理，甚至是被投递。客户端只需要将消息发送给消息代理，就可以确信消息会被投递给相应的目的地。</p>
<p>因为不需要等待，所以客户端可以继续执行其他任务。这种方式可以有效地节省时间，所以客户端的性能能够极大的提高。</p>
<h3 id="面向消息和解耦">面向消息和解耦</h3>
<p>与面向方法调用的RPC通信不同，发送异步消息是以数据为中心的。这意味着客户端并没有与特定的方法签名绑定。任何可以处理数据的队列或主题订阅者都可以处理由客户端发送的消息，而客户端不必了解远程服务的任何规范。</p>
<h3 id="位置独立">位置独立</h3>
<p>同步RPC服务通常需要网络地址来定位。这意味着客户端无法灵活地适应网络拓扑的改变。如果服务的IP地址改变了，或者服务被配置为监听其他端口，客户端必须进行相应的调整，否则无法访问服务。</p>
<p>与之相反，消息客户端不必知道谁会处理它们的消息，或者服务的位置在哪里。客户端只需要了解需要通过哪个队列或主题来发送消息。因此，只要服务能够从队列或主题中获取消息即可，消息客户端根本不需要关注服务来自哪里。</p>
<p>在点对点模型中，可以利用这种位置的独立性来创建服务的集群。如果客户端不知道服务的位置，并且服务的唯一要求就是可以访问消息代理，那么我们就可以配置多个服务从同一个队列中接收消息。如果服务过载，处理能力不足，我们只需要添加一些新的服务实例来监听相同的队列就可以了。</p>
<p>在发布-订阅模型中，位置独立性会产生另一种有趣的效应。多个服务可以订阅同一个主题，接收相同消息的副本。但是每一个服务对消息的处理逻辑却可能有所不同。例如，假设我们有一组服务可以共同处理描述新员工信息的消息。一个服务可能会在工资系统中增加该员工，另一个服务则会将新员工增加到HR门户中，同时还有一个服务为新员工分配可访问系统的权限。每一个服务都基于相同的数据（都是从同一个主题接收的），但各自进行独立的处理。</p>
<h3 id="确保投递">确保投递</h3>
<p>为了使客户端可以与同步服务通信，服务必须监听指定的IP地址和端口。如果服务崩溃了，或者由于某种原因无法使用了，客户端将不能继续处理。</p>
<p>但是，当发送异步消息时，客户端完全可以相信消息会被投递。即使在消息发送时，服务无法使用，消息也会被存储起来，直到服务重新可以使用为止。</p>
<p>现在，我们已经对异步消息的基础知识有所了解，接下来看一下如何将其付诸实施。首先，我们会使用JMS来发送和接收消息。</p>
<h1>Spring JMS（ActiveMQ）</h1>
<p>Java消息服务（Java Message Service ，JMS）是一个Java标准，定义了使用消息代理的通用API。在JMS出现之前，每个消息代理都有私有的API，这就使得不同代理之间的消息代码很难通用。但是借助JMS，所有遵从规范的实现都使用通用的接口，这就类似于JDBC为数据库操作提供了通用的接口一样。</p>
<p>Spring通过基于模板的抽象为JMS功能提供了支持，这个模板也就是JmsTemplate。使用JmsTemplate，能够非常容易地在消息生产方发送队列和主题消息，在消费消息的那一方，也能够非常容易地接收这些消息。Spring还提供了消息驱动POJO的理念：这是一个简单的Java对象，它能够以异步的方式响应队列或主题上到达的消息。</p>
<p>我们将会讨论Spring对JMS的支持，包括JmsTemplate和消息驱动POJO。但是在发送和接收消息之前，我们首先需要一个消息代理，它能够在消息的生产者和消费者之间传递消息。对Spring JMS的探索就从在Spring中搭建消息代理开始吧。</p>
<h2 id="搭建消息代理-ActiveMQ">搭建消息代理-ActiveMQ</h2>
<p>ActiveMQ是一个伟大的开源消息代理产品，也是使用JMS进行异步消息传递的最佳选择。在我编写本书的时候，ActiveMQ的最新版本为5.9.1。在开始使用ActiveMQ之前，我们需要从<a href="http://activemq.apache.org/" target="_blank" rel="noopener">http://activemq.apache.org</a>下载二进制发行包。下载完ActiveMQ后，我们将其解压缩到本地硬盘中。在解压目录中，我们会找到文件activemq-core-5.9.1.jar。为了能够使用ActiveMQ的API，我们需要将此JAR文件添加到应用程序的类路径中。</p>
<p>在bin目录下，我们可以看到为各种操作系统所创建的对应子目录。在这些子目录下，我们可以找到用于启动ActiveMQ的脚本。例如，要在OS X下启动ActiveMQ，我们只需要在“bin/macosx”目录下运行activemq start。运行脚本后，ActiveMQ就准备好了，这时可以使用它作为消息代理。</p>
<h2 id="创建连接工厂-ActiveMQConnectionFactory">创建连接工厂-ActiveMQConnectionFactory</h2>
<p>在本章中，我们将了解如何采用不同的方式在Spring中使用JMS发送和接收消息。在所有的示例中，我们都需要借助JMS连接工厂通过消息代理发送消息。因为选择了ActiveMQ作为我们的消息代理，所以我们必须配置JMS连接工厂，让它知道如何连接到ActiveMQ。 <strong>ActiveMQConnectionFactory是ActiveMQ自带的连接工厂，在Spring中可以使用如下方式进行配置</strong> ：</p>
<p><img src="https://hexo-1300861231.cos.ap-shanghai.myqcloud.com/1584859091_20200322142653148_16948.png" alt></p>
<p>默认情况下，ActiveMQConnectionFactory会假设ActiveMQ代理监听localhost的61616端口。对于开发环境来说，这没有什么问题，但是在生产环境下，ActiveMQ可能会在不同的主机和/端口上。如果是这样的话，我们可以使用brokerURL属性来指定代理的URL：</p>
<p><img src="https://hexo-1300861231.cos.ap-shanghai.myqcloud.com/1584859091_20200322142652935_2752.png" alt></p>
<p>配置连接工厂还有另外一种方式，既然我们知道正在与ActiveMQ打交道，那我们就可以使用ActiveMQ自己的Spring配置命名空间来声明连接工厂（适用于ActiveMQ 4.1之后的所有版本）。首先，我们必须确保在Spring的配置文件中声明了amq命名空间：</p>
<p><img src="https://hexo-1300861231.cos.ap-shanghai.myqcloud.com/1584859091_20200322142652723_18427.png" alt></p>
<p>现在我们就可以使用 <code>&lt;amq:connectionFactory&gt;</code> 元素声明连接工厂：</p>
<p><img src="https://hexo-1300861231.cos.ap-shanghai.myqcloud.com/1584859091_20200322142652404_21625.png" alt></p>
<p>注意， <code>&lt;amq:connectionFactory&gt;</code> 元素很明显是为ActiveMQ所准备的。如果我们使用不同的消息代理实现，它们不一定会提供Spring配置命名空间。如果没有提供的话，那我们就需要使用 <code>&lt;bean&gt;</code> 来装配连接工厂。</p>
<p>在本章的后续内容中，我们会多次使用connectionFactory bean，但是现在，我们只需要通过配置brokerURL属性来告知连接工厂消息代理的位置就足够了。在本例中，brokerURL属性中的URL指定连接工厂要连接到本地机器的61616端口（这个端口是ActiveMQ监听的默认端口）上的ActiveMQ。</p>
<h2 id="声明ActiveMQ消息目的地-ActiveMQQueue、ActiveMQTopic">声明ActiveMQ消息目的地-ActiveMQQueue、ActiveMQTopic</h2>
<p>除了连接工厂外，我们还需要消息传递的目的地。目的地可以是一个队列，也可以是一个主题，这取决于应用的需求。</p>
<p>不论使用的是队列还是主题，我们都必须使用特定的消息代理实现类在Spring中配置目的地bean。例如，下面的 <code>&lt;bean&gt;</code> 声明定义了一个ActiveMQ队列：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"queue"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">class</span>=<span class="string">"org.apache.activemq.command.ActiveMQQueue"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">c:_</span>=<span class="string">"spitter.queue"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>同样，下面的 <code>&lt;bean&gt;</code> 声明定义了一个ActiveMQ主题：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"topic"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">class</span>=<span class="string">"org.apache.activemg.command.ActiveMQTopic"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">c:_</span>=<span class="string">"spitter.topic"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>在第一个示例中，构造器指定了队列的名称spitter.queue，这样消息代理就能获知该信息，而在接下来示例中，名称则为spitter.topic。</p>
<p>与连接工厂相似的是，ActiveMQ命名空间提供了另一种方式来声明队列和主题。对于队列，我们可以使用 <code>&lt;amq:quence&gt;</code> 元素来声明：</p>
<p><img src="https://hexo-1300861231.cos.ap-shanghai.myqcloud.com/1584859090_20200322142652190_31273.png" alt></p>
<p>如果是JMS主题，我们可以使用 <code>&lt;amq:topic&gt;</code> 元素来声明：</p>
<p><img src="https://hexo-1300861231.cos.ap-shanghai.myqcloud.com/1584859090_20200322142651979_1024.png" alt></p>
<p>不管是哪种类型，都是借助physicalName属性指定消息通道的名称。</p>
<p>到此为止，我们已经看到了如何声明使用JMS所需的组件。现在我们已经准备好发送和接收消息了。为此，我们将使用Spring的JmsTemplate——Spring 对JMS支持的核心部分。但是首先，让我们先看看如果没有JmsTemplate，JMS是怎样使用的，以此了解JmsTemplate到底提供了些什么。</p>
<h2 id="使用Spring的JMS模板消除重复代码">使用Spring的JMS模板消除重复代码</h2>
<p>正如我们所看到的，JMS为Java开发者提供了与消息代理进行交互来发送和接收消息的标准API，而且几乎每个消息代理实现都支持JMS，因此我们不必因为使用不同的消息代理而学习私有的消息API。</p>
<p>虽然JMS为所有的消息代理提供了统一的接口，但是这种接口用起来并不是很方便。使用JMS发送和接收消息并不像拿一张邮票并贴在信封上那么简单。正如我们将要看到的，JMS还要求我们为邮递车加油（只是比喻的说法）。</p>
<h3 id="处理失控的JMS代码">处理失控的JMS代码</h3>
<p>在前面小节中，我向你展示了传统的JDBC代码在处理连接、语句、结果集和异常时是多么冗长和繁杂。遗憾的是，传统的JMS使用了类似的编程模型，如下面的程序清单所示。</p>
<p><img src="https://hexo-1300861231.cos.ap-shanghai.myqcloud.com/1584859090_20200322142651767_9769.jpg" alt></p>
<p>再次声明这是一段失控的代码！就像JDBC示例一样，差不多使用了20行代码，只是为了发送一条“Hello world!”消息。实际上，其中只有几行代码是用来发送消息的，剩下的代码仅仅是为了发送消息而进行的设置。</p>
<p>接收端也没有好到哪里去，如下面的程序清单所示。也是用一大段代码来实现如此简单的事情。如果我们逐行地比较，我们会发现它们几乎是完全一样的。如果查看上千个其他的JMS例子，我们会发现它们也是很相似的。只不过，其中一些会从JNDI中获取连接工厂，而另一些则是使用主题代替队列。但是无论如何，它们都大致遵循相同的模式。</p>
<p><img src="https://hexo-1300861231.cos.ap-shanghai.myqcloud.com/1584859090_20200322142651445_11640.jpg" alt></p>
<p>因为这些样板式代码，我们每次使用JMS时都要不断地做很多重复工作。更糟糕的是，你会发现我们在重复编写其他开发者的JMS代码。</p>
<p>我们已经在前面看到了Spring的JdbcTemplate是如何处理失控的JDBC样板式代码的。现在，让我来介绍一下Spring的JmsTemplate如何对JMS的样板式代码实现相同的功能。</p>
<h3 id="使用JMS模版">使用JMS模版</h3>
<p>针对如何消除冗长和重复的JMS代码，Spring给出的解决方案是JmsTemplate。JmsTemplate可以创建连接、获得会话以及发送和接收消息。这使得我们可以专注于构建要发送的消息或者处理接收到的消息。</p>
<p>另外，JmsTemplate可以处理所有抛出的笨拙的JMSException异常。如果在使用JmsTemplate时抛出JMSException异常，JmsTemplate将捕获该异常，然后抛出一个非检查型异常，该异常是Spring自带的JmsException异常的子类。下表列出了标准的JMSException异常与Spring的非检查型异常之间的映射关系。</p>
<table>
<thead>
<tr>
<th><code>Spring（org.springframework.jms.*）</code></th>
<th><code>标准的JMS（javax.jms.*）</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>DestinationResolutionException</td>
<td>Spring特有的——当Spring无法解析目的地名称时抛出</td>
</tr>
<tr>
<td>IllegalStateException</td>
<td>IllegalStateException</td>
</tr>
<tr>
<td>InvalidClientIDException</td>
<td>InvalidClientIDException</td>
</tr>
<tr>
<td>InvalidDestinationException</td>
<td>InvalidSelectorException</td>
</tr>
<tr>
<td>InvalidSelectorException</td>
<td>InvalidSelectorException</td>
</tr>
<tr>
<td>JmsSecurityException</td>
<td>JmsSecurityException</td>
</tr>
<tr>
<td>ListenerExecutionFailedException</td>
<td>Spring特有的——当监听器方法执行失败时抛出</td>
</tr>
<tr>
<td>MessageConversionException</td>
<td>Spring特有的——当消息转换失败时抛出</td>
</tr>
<tr>
<td>MessageEOFException</td>
<td>MessageEOFException</td>
</tr>
<tr>
<td>MessageFormatException</td>
<td>MessageFormatException</td>
</tr>
<tr>
<td>MessageNotReadableException</td>
<td>MessageNotReadableException</td>
</tr>
<tr>
<td>MessageNotWriteableException</td>
<td>MessageNotWriteableException</td>
</tr>
<tr>
<td>ResourceAllocationException</td>
<td>ResourceAllocationException</td>
</tr>
<tr>
<td>SynchedLocalTransactionFailedException</td>
<td>Spring特有的——当同步的本地事务不能完成时抛出</td>
</tr>
<tr>
<td>TransactionInprogressException</td>
<td>TransactionInprogressException</td>
</tr>
<tr>
<td>TransactionRolledBackException</td>
<td>TransactionRolledBackException</td>
</tr>
<tr>
<td>UncategorizedJmsException</td>
<td>Spring特有的——当没有其他异常适用时抛出</td>
</tr>
</tbody>
</table>
<p>对于JMS API来说，JMSException的确提供了丰富且具有描述性的子类集合，让我们更清楚地知道发生了什么错误。不过，所有的JMSException异常的子类都是检查型异常，因此必须要捕获。JmsTemplate为我们捕获这些异常，并重新抛出对应非检查型JMSException异常的子类。</p>
<p>为了使用JmsTemplate，我们需要在Spring的配置文件中将它声明为一个bean。如下的XML可以完成这项工作：</p>
<p><img src="https://hexo-1300861231.cos.ap-shanghai.myqcloud.com/1584859090_20200322142650724_8086.png" alt></p>
<p>因为JmsTemplate需要知道如何连接到消息代理，所以我们必须为connectionFactory属性设置实现了JMS的ConnectionFactory接口的bean引用。在这里，我们使用在前面声明的connectionFactorybean引用来装配该属性。</p>
<p>这就是配置JmsTemplate所需要做的所有工作——现在JmsTemplate已经准备好了。让我们开始发送消息吧！</p>
<h2 id="使用JmsTemplate发送消息">使用JmsTemplate发送消息</h2>
<p>在我们想建立的Spittr应用程序中，其中有一个特性就是当创建Spittle的时候提醒其他用户（或许是通过E-mail）。我们可以在增加Spittle的方法中直接实现该特性。但是搞清楚发送提醒给谁以及实际发送这些提醒可能需要一段时间，这会影响到应用的性能。当增加一个新的Spittle时，我们希望应用是敏捷的，能够快速做出响应。</p>
<p>与其在增加Spittle时浪费时间发送这些信息，不如对该项工作进行排队，在响应返回给用户之后再处理它。与直接发送消息给其他用户所花费的时间相比，发送消息给队列或主题所花费的时间是微不足道的。</p>
<p>为了在Spittle创建的时候异步发送spittle提醒，让我们为Spittr应用引入AlertService：</p>
<p><img src="https://hexo-1300861231.cos.ap-shanghai.myqcloud.com/1584859089_20200322142650509_30217.png" alt></p>
<p>正如我们所看到的，AlertService是一个接口，只定义了一个操作—— sendSpittleAlert()。</p>
<p>如下面程序清单所示，AlertServiceImpl实现了AlertService接口，它使用JmsOperation（JmsTemplate所实现的接口）将Spittle对象发送给消息队列，而队列会在稍后得到处理。</p>
<p><img src="https://hexo-1300861231.cos.ap-shanghai.myqcloud.com/1584859089_20200322142650296_851.jpg" alt></p>
<p>JmsOperations的send()方法的第一个参数是JMS目的地名称，标识消息将发送给谁。当调用 <strong>send()方法</strong> 时，JmsTemplate将负责获得JMS连接、会话并代表发送者发送消息（如下图所示）。</p>
<p><img src="https://hexo-1300861231.cos.ap-shanghai.myqcloud.com/1584859089_20200322142649973_28666.png" alt></p>
<p>我们使用MessageCreator（在这里的实现是作为一个匿名内部类）来构造消息。在MessageCreator的createMessage()方法中，我们通过session创建了一个对象消息：传入一个Spittle对象，返回一个对象消息。</p>
<p>就是这么简单！注意， <strong>sendSpittleAlert()方法专注于组装和发送消息。在这里没有连接或会话管理的代码，JmsTemplate帮我们处理了所有的相关事项，而且我们也不需要捕获JMSException异常。JmsTemplate将捕获抛出的所有JMSException异常，然后重新抛出上表所列的某一种非检查型异常</strong> 。</p>
<h3 id="设置默认目的地">设置默认目的地</h3>
<p>在上面程序清单中，我们明确指定了一个目的地，在send()方法中将Spittle消息发向此目的地。当我们希望通过程序选择一个目的地时，这种形式的send()方法很适用。但是在AlertServiceImpl案例中，我们总是将Spittle消息发给相同的目的地，所以这种形式的send()方法并不能带来明显的好处。</p>
<p>与其每次发送消息时都指定一个目的地，不如我们为JmsTemplate装配一个默认的目的地：</p>
<p><img src="https://hexo-1300861231.cos.ap-shanghai.myqcloud.com/1584859089_20200322142649761_31501.png" alt></p>
<p>在这里，将目的地的名称设置为spittle.alert.queue，但它只是一个名称：它并没有说明你所处理的目的地是什么类型。 <strong>如果已经存在该名称的队列或主题的话，就会使用已有的。如果尚未存在的话，将会创建一个新的目的地（通常会是队列）。但是，如果你想指定要创建的目的地类型的话，那么你可以将之前创建的队列或主题的目的地bean装配进来</strong> ：</p>
<p><img src="https://hexo-1300861231.cos.ap-shanghai.myqcloud.com/1584859088_20200322142649549_14283.png" alt></p>
<p>现在，调用JmsTemplate的send()方法时，我们可以去除第一个参数了：</p>
<p><img src="https://hexo-1300861231.cos.ap-shanghai.myqcloud.com/1584859088_20200322142649336_12137.png" alt></p>
<p>这种形式的send()方法只需要传入一个MessageCreator。因为希望消息发送给默认目的地，所以我们没有必要再指定特定的目的地。</p>
<p>在调用send()方法时，我们不必再显式指定目的地能够让任务得以简化。但是如果我们使用消息转换器的话，发送消息会更加简单。</p>
<h3 id="在发送时，对消息进行转换">在发送时，对消息进行转换</h3>
<p>除了send()方法，JmsTemplate还提供了convertAndSend()方法。与send()方法不同，convertAndSend()方法并不需要MessageCreator作为参数。这是因为convertAndSend()会使用内置的消息转换器（message converter）为我们创建消息。</p>
<p>当我们使用convertAndSend()时，sendSpittleAlert()可以减少到方法体中只包含一行代码：</p>
<p><img src="https://hexo-1300861231.cos.ap-shanghai.myqcloud.com/1584859088_20200322142649124_30048.png" alt></p>
<p>就像变魔术一样，Spittle会在发送之前转换为Message。不过就像所有的魔术一样，JmsTemplate内部会进行一些处理。它使用一个MessageConverter的实现类将对象转换为Message。</p>
<p>MessageConverter是Spring定义的接口，只有两个需要实现的方法：</p>
<p><img src="https://hexo-1300861231.cos.ap-shanghai.myqcloud.com/1584859088_20200322142648911_7986.png" alt></p>
<p>尽管这个接口实现起来很简单，但我们通常并没有必要创建自定义的实现。Spring已经提供了多个实现，如下表所示。（所有的消息转换器都位于org.springframework.jms.support.converter包中）</p>
<table>
<thead>
<tr>
<th>消息转换器</th>
<th>功　　能</th>
</tr>
</thead>
<tbody>
<tr>
<td>MappingJacksonMessageConverter</td>
<td>使用Jackson JSON库实现消息与JSON格式之间的相互转换</td>
</tr>
<tr>
<td>MappingJackson2MessageConverter</td>
<td>使用Jackson 2 JSON库实现消息与JSON格式之间的相互转换</td>
</tr>
<tr>
<td>MarshallingMessageConverter</td>
<td>使用JAXB库实现消息与XML格式之间的相互转换</td>
</tr>
<tr>
<td>SimpleMessageConverter</td>
<td>实现String与TextMessage之间的相互转换，字节数组与BytesMessage之间的相互转换，Map与MapMessage之间的相互转换以及Serializable对象与ObjectMessage之间的相互转换</td>
</tr>
</tbody>
</table>
<p>默认情况下，JmsTemplate在convertAndSend()方法中会使用SimpleMessage Converter。但是通过将消息转换器声明为bean并将其注入到JmsTemplate的messageConverter属性中，我们可以重写这种行为。例如，如果你想使用JSON消息的话，那么可以声明一个MappingJacksonMessageConverter bean：</p>
<p><img src="https://hexo-1300861231.cos.ap-shanghai.myqcloud.com/1584859088_20200322142648697_18304.png" alt></p>
<p>然后，我们可以将其注入到JmsTemplate中，如下所示：</p>
<p><img src="https://hexo-1300861231.cos.ap-shanghai.myqcloud.com/1584859087_20200322142648484_13380.png" alt></p>
<p>各个消息转换器可能会有额外的配置，进而实现转换过程的细粒度控制。例如，MappingJacksonMessageConverter能够让我们配置转码以及自定义Jackson ObjectMapper。可以查阅每个消息转换器的JavaDoc以了解如何更加细粒度地配置它们。</p>
<h2 id="使用JmsTemplate同步接收消息">使用JmsTemplate同步接收消息</h2>
<p>现在我们已经了解了如何使用JmsTemplate发送消息。但如果我们是接收端，那要怎么办呢？JmsTemplate是不是也可以接收消息呢？</p>
<p>没错，的确可以。事实上，使用JmsTemplate接收消息甚至更简单，我们只需要调用JmsTemplate的receive()方法即可，如下面程序清单所示。</p>
<p><strong>当调用JmsTemplate的receive()方法时，JmsTemplate会尝试从消息代理中获取一个消息。如果没有可用的消息，receive()方法会一直等待，直到获得消息为止。</strong> 下图展示了这个交互过程。</p>
<p><img src="https://hexo-1300861231.cos.ap-shanghai.myqcloud.com/1584859087_20200322142648171_5421.jpg" alt></p>
<p><img src="https://hexo-1300861231.cos.ap-shanghai.myqcloud.com/1584859087_20200322142647955_15102.png" alt></p>
<p>因为我们知道Spittle消息是作为一个对象消息来发送的，所以它可以在到达后转型为ObjectMessage。然后，我们调用getObject()方法把ObjectMessage转换为Spittle对象并返回此对象。</p>
<p>但是这里存在一个问题，我们不得不对可能抛出的JMSException进行处理。正如我已经提到的，JmsTemplate可以很好地处理抛出的JmsException检查型异常，然后把异常转换为Spring非检查型异常JmsException并重新抛出。但是它只对调用JmsTemplate的方法时才适用。JmsTemplate无法处理调用ObjectMessage的getObject()方法时所抛出的JMSException异常。</p>
<p>因此，我们要么捕获JMSException异常，要么声明本方法抛出JMSException异常。为了遵循Spring规避检查型异常的设计理念，我们不建议本方法抛出JMSException异常，所以我们选择捕获该异常。在catch代码块中，我们使用Spring中JmsUtils的convertJmsAccessException()方法把检查型异常JMSException转换为非检查型异常JmsException。这其实是在其他场景中由JmsTemplate为我们做的事情。</p>
<p>在receiveSpittleAlert()方法中，我们可以改善的一点就是使用消息转换器。在convertAndSend()中，我们已经看到了如何将对象转换为Message。不过，它们还可以用在接收端，也就是使用JmsTemplate的receiveAndConvert()：</p>
<p><img src="https://hexo-1300861231.cos.ap-shanghai.myqcloud.com/1584859087_20200322142647643_6053.png" alt></p>
<p>现在，没有必要将Message转换为ObjectMessage，也没有必要通过调用getObject()来获取Spittle，更无需担心检查型的JMSException异常。这个新的retrieve SpittleAlert()简洁了许多。但是，依然还有一个很小且不容易察觉的问题。</p>
<p><strong>使用JmsTemplate接收消息的最大缺点在于receive()和receiveAndConvert()方法都是同步的。这意味着接收者必须耐心等待消息的到来，因此这些方法会一直被阻塞，直到有可用消息（或者直到超时）。同步接收异步发送的消息，是不是感觉很怪异？</strong></p>
<p>这就是消息驱动POJO的用武之处。让我们看看如何使用能够响应消息的组件 <strong>异步接收消息</strong> ，而不是一直等待消息的到来。</p>
<h2 id="使用消息驱动的POJO">使用消息驱动的POJO</h2>
<p>当我们调用JmsTemplate的receive()方法时，JmsTemplate会查看队列或主题中是否有消息，直到收到消息或者等待超时才会返回。这期间，应用无法处理任何事情，只能等待是否有消息。如果应用能够继续进行其他业务处理，当消息到达时再去通知它，不是更好吗？</p>
<p>EJB2规范的一个重要内容是引入了 <strong>消息驱动</strong> bean（message-driven bean，MDB）。MDB是可以异步处理消息的EJB。换句话说，MDB将JMS目的地中的消息作为事件，并对这些事件进行响应。而与之相反的是，同步消息接收者在消息可用前会一直处于阻塞状态。</p>
<p>MDB是EJB中的一个亮点。即使那些狂热的EJB反对者也认为MDB可以优雅地处理消息。EJB 2 MDB的唯一缺点是它们必须要实现java.ejb.MessageDrivenBean。此外，它们还必须实现一些EJB生命周期的回调方法。简而言之，EJB 2 MDB 不是纯的POJO。</p>
<p>在EJB 3规范中，MDB进一步简化了，使其更像POJO。我们不再需要实现MessageDrivenBean接口，而是实现更通用的javax.jms.MessageListener接口，并使用@MessageDriven注解标注MDB。</p>
<p>Spring 2.0提供了它自己的消息驱动bean来满足异步接收消息的需求，这种形式与EJB 3的MDB很相似。在本节中，我们将学习到Spring是如何使用消息驱动POJO（我们将其简称为MDP）来支持异步接收消息的。</p>
<h3 id="创建消息监听器">创建消息监听器</h3>
<p>如果使用EJB的消息驱动模型来创建Spittle的提醒处理器，我们需要使用@MessageDriven注解进行标注。即使它不是严格要求的，但EJB规范还是建议MDB实现MessageListener接口。Spittle的提醒处理器最终可能是这样的：</p>
<p><img src="https://hexo-1300861231.cos.ap-shanghai.myqcloud.com/1584859087_20200322142647427_26508.png" alt></p>
<p>想象一下，如果消息驱动组件不需要实现MessageListener接口，世界将是多么的简单。在这里，天是蔚蓝的，鸟儿唱着我们喜欢的歌，我们不再需要实现onMessage()方法或者注入Messge DrivenContext。</p>
<p>好吧，可能EJB 3规范所要求的MDB也算不上太麻烦。但是事实上，SpittleAlertHandler的EJB 3实现太依赖于EJB的消息驱动API，并不是我们所希望的POJO。理想情况下，我们希望提醒处理器能够处理消息，但是不用编码，就好像它知道应该做什么。</p>
<p>Spring提供了以POJO的方式处理消息的能力，这些消息来自于JMS的队列或主题中。例如，基于POJO实现SpittleAlertHandler就足以做到这一点。</p>
<p><img src="https://hexo-1300861231.cos.ap-shanghai.myqcloud.com/1584859086_20200322142647211_30993.jpg" alt></p>
<p>虽然改变天空的颜色和训练鸟儿歌唱超出了Spring的范围，但上面程序清单所展示的现实与我描绘的理想世界非常接近。我们稍后会编写handleSpittleAlert()方法的具体内容。现在，程序清单中所展示的SpittleAlertHandler没有任何JMS的痕迹。从任意一个角度观察，它都是一个纯粹的POJO。它仍然可以像EJB那样处理消息，只不过它还需要一些Spring的配置。</p>
<h3 id="配置消息监听器">配置消息监听器</h3>
<p>为POJO赋予消息接收能力的诀窍是在Spring中把它配置为消息监听器。Spring的jms命名空间为我们提供了所需要的一切。首先，让我们先把处理器声明为bean：</p>
<p><img src="https://hexo-1300861231.cos.ap-shanghai.myqcloud.com/1584859086_20200322142646998_25666.png" alt></p>
<p>然后，为了把SpittleAlertHandler转变为消息驱动的POJO，我们需要把这个bean声明为消息监听器：</p>
<p><img src="https://hexo-1300861231.cos.ap-shanghai.myqcloud.com/1584859086_20200322142646784_28455.png" alt></p>
<p>在这里，我们在消息监听器容器中包含了一个消息监听器。 <strong>消息监听器容器</strong> （message listener container）是一个特殊的bean，它可以监控JMS目的地并等待消息到达。一旦有消息到达，它取出消息，然后把消息传给任意一个对此消息感兴趣的消息监听器。如图展示了这个交互过程。</p>
<p><img src="https://hexo-1300861231.cos.ap-shanghai.myqcloud.com/1584859086_20200322142646571_3803.png" alt></p>
<p>当消息到达时，消息将转给消息监听器（例如消息驱动的POJO）。</p>
<p>为了在Spring中配置消息监听器容器和消息监听器，我们使用了Spring jms命名空间中的两个元素。 <strong><code>&lt;jms:listener-container&gt;</code>中包含了<code>&lt;jms:listener&gt;</code>元素</strong> 。这里的connection-factory属性配置了对connectionFactory的引用，容器中的每个 <code>&lt;jms:listener&gt;</code> 都使用这个连接工厂进行消息监听。在本示例中，connection-factory属性可以移除，因为该属性的默认值就是connectionFactory。</p>
<p>对于 <code>&lt;jms:listener&gt;</code> 元素，它用于标识一个bean和一个可以处理消息的方法。为了处理Spittle提醒消息，ref元素引用了spittleHandler bean。当消息到达spitter.alert.queue队列（通过destination属性配置）时，spittleHandlerbean的handleSpittleAlert()方法（通过method属性指定的）会被触发。</p>
<p>值得一提的是， <strong>如果ref属性所标示的bean实现了MessageListener，那就没有必要再指定method属性了，默认就会调用onMessage()方法</strong> 。</p>
<h2 id="使用基于消息的RPC">使用基于消息的RPC</h2>
<p>在前面，我们展示了Spring把bean的方法暴为远程服务以及从客户端向这些服务发起调用的几种方式。在本章，我们学习了如何通过队列和主题在应用程序之间发送消息。现在我们将了解一下如何使用JMS作为传输通道来进行远程调用。</p>
<p>让我们回顾一下，Spring提供了多种方式把bean导出为远程服务。我们使用RmiServiceExporter把bean导出为RMI服务，使用HessianExporter和BurlapExporter导出为基于HTTP的Hessian和Burlap服务，还使用HttpInvoker Service Exporter创建基于HTTP的HTTP invoker服务。类似的，Spring还提供了一种基于JMS的服务导出器。</p>
<p>为了支持基于消息的RPC，Spring提供了 <strong>JmsInvokerServiceExporter</strong> ，它可以把bean导出为基于消息的服务；为客户端提供了 <strong>JmsInvokerProxyFactoryBean</strong> 来使用这些服务。</p>
<h3 id="导出基于JMS的服务">导出基于JMS的服务</h3>
<p>JmsInvokerServiceExporter很类似于其他的服务导出器。事实上，JmsInvokerServiceExporter与HttpInvokerServiceExporter在名称上有某种对称型。如果HttpInvokerServiceExporter可以导出基于HTTP通信的服务，那么JmsInvokerServiceExporter就应该可以导出基于JMS的服务。</p>
<p>为了演示JmsInvokerServiceExporter是如何工作的，考虑如下的AlertServiceImpl。AlertServiceImpl是一个处理JMS消息的POJO，但是不依赖于JMS：</p>
<p><img src="https://hexo-1300861231.cos.ap-shanghai.myqcloud.com/1584859085_20200322142646257_5701.jpg" alt></p>
<p>我们现在不要过于关注sendSpittleAlert()方法的细节。现在，我们需要关注的重点在于AlertServiceImpl是一个简单的POJO，没有任何迹象标示它要用来处理JMS消息。它只是实现了简单的AlertService接口，该接口如下所示：</p>
<p><img src="https://hexo-1300861231.cos.ap-shanghai.myqcloud.com/1584859043_20200322142645935_7785.png" alt></p>
<p>正如我们所看到的，AlertServiceImpl使用了@Component注解来标注，所以它会被Spring自动发现并注册为Spring应用上下文中ID为alertService的bean。在配置JmsInvokerServiceExporter时，我们将引用这个bean：</p>
<p><img src="https://hexo-1300861231.cos.ap-shanghai.myqcloud.com/1584859043_20200322142645724_20700.png" alt></p>
<p>这个bean的属性描述了导出的服务应该是什么样子的。service属性设置为alertService bean的引用，它是远程服务的实现。同时，serviceInterface属性设置为远程服务对外提供接口的全限定类名。</p>
<p>导出器的属性并没有描述服务如何基于JMS通信的细节。但好消息是 <strong>JmsInvokerServiceExporter可以充当JMS监听器。因此，我们使用<code>&lt;jms:listenercontainer&gt;</code>元素配置它</strong> ：</p>
<p><img src="https://hexo-1300861231.cos.ap-shanghai.myqcloud.com/1584859043_20200322142645512_31267.png" alt></p>
<p>我们为JMS监听器容器指定了连接工厂，所以它能够知道如何连接消息代理，而 <code>&lt;jms:listener&gt;</code> 声明指定了远程消息的目的地。</p>
<h3 id="使用基于JMS的服务">使用基于JMS的服务</h3>
<p>这时候，基于JMS的提醒服务已经准备好了，等待队列中名字为spitter.alert.queue的RPC消息到达。在客户端，JmsInvokerProxyFactoryBean用来访问服务。</p>
<p>JmsInvokerProxyFactoryBean很类似于我们在Spring远程调用服务中所讨论的其他远程代理工厂bean。它隐藏了访问远程服务的细节，并提供一个易用的接口，通过该接口客户端与远程服务进行交互。与代理RMI服务或HTTP服务的最大区别在于，JmsInvokerProxyFactoryBean代理了通过JmsInvokerServiceExporter所导出的JMS服务。</p>
<p>为了使用提醒服务，我们可以像下面那样配置JmsInvokerProxyFactoryBean：</p>
<p><img src="https://hexo-1300861231.cos.ap-shanghai.myqcloud.com/1584859043_20200322142645300_24601.png" alt></p>
<p>connectionFactory和queryName属性指定了RPC消息如何被投递——在这里，也就是在给定的连接工厂中，我们所配置的消息代理里面名为spitter.alert.queue的队列。对于serviceInterface，指定了代理应该通过AlertService接口暴功能。</p>
<h1>Spring AMQP（RabbitMQ）</h1>
<p>多年来，JMS一直是Java应用中主流的消息解决方案。但是对于Java和Spring开发者来说，JMS并不是唯一的消息可选方案。在过去的几年中， <strong>高级消息队列协议</strong> （Advanced Message Queuing Protocol ，AMQP）得到了广泛的关注。因此，Spring也为通过AMQP发送消息提供了支持，这就是我们下面要讲解的内容。</p>
<p>你可能会疑惑为什么还需要另外一个消息规范。难道JMS还不够好吗？AMQP提供了哪些JMS所不具备的特性呢？</p>
<p>实际上，AMQP具有多项JMS所不具备的优势。首先，AMQP为消息定义了线路层（wire-level protocol）的协议，而JMS所定义的是API规范。JMS的API协议能够确保所有的实现都能通过通用的API来使用，但是并不能保证某个JMS实现所发送的消息能够被另外不同的JMS实现所使用。而AMQP的线路层协议规范了消息的格式，消息在生产者和消费者间传送的时候会遵循这个格式。这样AMQP在互相协作方面就要优于JMS——它不仅能跨不同的AMQP实现，还能跨语言和平台。</p>
<p>相比JMS，AMQP另外一个明显的优势在于它具有更加灵活和透明的消息模型。使用JMS的话，只有两种消息模型可供选择：点对点和发布-订阅。这两种模型在AMQP当然都是可以实现的，但AMQP还能够让我们以其他的多种方式来发送消息，这是通过将消息的生产者与存放消息的队列解耦实现的。</p>
<p>Spring AMQP是Spring框架的扩展，它能够让我们在Spring应用中使用AMQP风格的消息。稍后可以看到，Spring AMQP提供了一个API，借助这个API，我们能够以非常类似于Spring JMS抽象的形式来使用AMQP。这意味着，我们在本章之前所学习的JMS内容能够帮助你理解如何使用Spring AMQP来发送和接收消息。</p>
<p>我们稍后就会介绍如何使用Spring AMQP，但是在深入学习如何在Spring中发送和接收消息之前，首先看一下到底是什么让AMQP如此引人关注。</p>
<h2 id="AMQP简介">AMQP简介</h2>
<p>简单回忆一下JMS的消息模型，可能会有助于理解AMQP的消息模型。在JMS中，有三个主要的参与者：消息的生产者、消息的消费者以及在生产者和消费者之间传递消息的通道（队列或主题）。</p>
<p>在JMS中，通道有助于解耦消息的生产者和消费者，但是这两者依然会与通道相耦合。生产者会将消息发布到一个特定的队列或主题上，消费者从特定的队列或主题上接收这些消息。通道具有双重责任，也就是传递数据以及确定这些消息该发送到什么地方，队列的话会使用点对点算法发送，主题的话就使用发布-订阅的方式。</p>
<p>与之不同的是，AMQP的生产者并不会直接将消息发布到队列中。 <strong>AMQP在消息的生产者以及传递信息的队列之间引入了一种间接的机制：Exchange。</strong> 这种关系如图所示。消息的生产者与消息队列之间实现了解耦</p>
<p><img src="https://hexo-1300861231.cos.ap-shanghai.myqcloud.com/1584859042_20200322142644986_8577.png" alt></p>
<p>可以看到，消息的生产者将信息发布到一个Exchange。Exchange会绑定到一个或多个队列上，它负责将信息路由到队列上。信息的消费者会从队列中提取数据并进行处理。</p>
<p>上图所没有展现出来的一点是Exchange不是简单地将消息传递到队列中，并不仅仅是一种穿透（pass-through）机制。AMQP定义了四种不同类型的Exchange，每一种都有不同的路由算法，这些算法决定了是否要将信息放到队列中。根据Exchange的算法不同，它可能会使用消息的<em>routing key</em>和/或参数，并将其与Exchange和队列之间binding的routing key和参数进行对比。（routing key可以大致理解为Email的收件人地址，指定了预期的接收者。）如果对比结果满足相应的算法，那么消息将会路由到队列上。否则的话，将不会路由到队列上。</p>
<p>四种标准的AMQP Exchange如下所示：</p>
<ul>
<li>Direct：如果消息的routing key与binding的routing key直接匹配的话，消息将会路由到该队列上；</li>
<li>Topic：如果消息的routing key与binding的routing key符合通配符匹配的话，消息将会路由到该队列上；</li>
<li>Headers：如果消息参数表中的头信息和值都与bingding参数表中相匹配，消息将会路由到该队列上；</li>
<li>Fanout：不管消息的routing key和参数表的头信息/值是什么，消息将会路由到所有队列上。</li>
</ul>
<p>借助这四种类型的Exchange，很容易就能想到我们可以定义任意数量的路由模式，而不再仅限于点对点和发布-订阅的方式。好消息是，当发送和接收消息的时候，所涉及的路由算法对于如何编写消息的生产者和消费者并没有什么影响。简单来讲，生产者将信息发送给Exchange并带有一个routing key，消费者从队列中获取消息。</p>
<p>我们已经快速了解了AMQP消息的基本知识——此时应该已经能够理解我们接下来所要介绍的如何使用Spring发送和接收消息。但是，我建议你更深入的学习一下AMQP，可以阅读规范和www.amqp.org站点上的其他资料，或者可以阅读Alvaro Videla和Jason J.W. Williams所编写的《RabbitMQ in Action》（Manning, 2012, <a href="http://www.manning.com/videla/%EF%BC%89%E3%80%82" target="_blank" rel="noopener">www.manning.com/videla/）。</a></p>
<p>现在，我们结束对AMQP的抽象讨论，开始着手编写借助Spring AMQP发送和接收消息的代码。首先我们将看到的是一些通用的配置，它们同时适用于生产者和消费者。</p>
<h3 id="什么是RabbitMQ">什么是RabbitMQ</h3>
<p>RabbitMQ是一个流行的开源消息代理，它实现了AMQP。Spring AMQP为RabbitMQ提供了支持，包括RabbitMQ连接工厂、模板以及Spring配置命名空间。</p>
<p>在使用它发送和接收消息之前，你需要预先安装RabbitMQ。<a href="http://xn--www-vs9d8a435db4fknz.rabbitmq.com/download.html%E4%B8%8A%E6%89%BE%E5%88%B0%E5%AE%89%E8%A3%85%E6%8C%87%E5%8D%97%E3%80%82%E6%A0%B9%E6%8D%AE%E4%BD%A0%E6%89%80%E8%BF%90%E8%A1%8C%E7%9A%84OS%E4%B8%8D%E5%90%8C%EF%BC%8C%E8%BF%99%E4%BC%9A%E6%9C%89%E6%89%80%E5%B7%AE%E5%88%AB%EF%BC%8C%E6%89%80%E4%BB%A5%E6%A0%B9%E6%8D%AE%E7%8E%AF%E5%A2%83%E7%9A%84%E4%B8%8D%E5%90%8C%EF%BC%8C%E9%81%B5%E5%BE%AA%E7%9B%B8%E5%BA%94%E6%8C%87%E5%8D%97%E8%BF%9B%E8%A1%8C%E5%AE%89%E8%A3%85%E7%9A%84%E4%BB%BB%E5%8A%A1%E5%B0%B1%E7%95%99%E7%BB%99%E8%AF%BB%E8%80%85%E8%87%AA%E5%B7%B1%E5%AE%8C%E6%88%90%E3%80%82" target="_blank" rel="noopener">我们可以在www.rabbitmq.com/download.html上找到安装指南。根据你所运行的OS不同，这会有所差别，所以根据环境的不同，遵循相应指南进行安装的任务就留给读者自己完成。</a></p>
<h2 id="配置RabbitMQ连接工厂">配置RabbitMQ连接工厂</h2>
<p>当我们第一次使用Spring JMS抽象的时候，首先配置了一个连接工厂。与之类似，使用Spring AMQP前也要配置一个连接工厂。只不过，所要配置的不是JMS的连接工厂，而是需要配置AMQP的连接工厂。更具体来讲，需要配置RabbitMQ连接工厂。</p>
<p>配置RabbitMQ连接工厂最简单的方式就是使用Spring AMQP所提供的rabbit配置命名空间。为了使用这项功能，需要确保在Spring配置文件中已经声明了该模式：</p>
<p><img src="https://hexo-1300861231.cos.ap-shanghai.myqcloud.com/1584859042_20200322142644673_7732.png" alt></p>
<p>尽管不是必须的，但我还选择在这个配置中将rabbit作为首选的命名空间，将beans作为第二位的命名空间。这是因为在这个配置中，我会更多的声明rabbit而不是bean，这样的话，只会有少量的bean元素使用“beans:”前缀，而rabbit元素就能够避免使用前缀了。</p>
<p>rabbit命名空间包含了多个在Spring中配置RabbitMQ的元素。但此时，你最感兴趣的可能就是 <code>&lt;connection-factory&gt;</code> 。按照其最简单的形式，我们可以在配置RabbitMQ连接工厂的时候没有任何属性：</p>
<p><img src="https://hexo-1300861231.cos.ap-shanghai.myqcloud.com/1584859042_20200322142644358_14412.png" alt></p>
<p>这的确能够运行起来，但是所导致的结果就是连接工厂bean没有可用的bean ID，这样的话就难将连接工厂装配到需要它的bean中。因此，我们可能希望通过id属性为其设置一个bean ID：</p>
<p><img src="https://hexo-1300861231.cos.ap-shanghai.myqcloud.com/1584859042_20200322142644146_1995.png" alt></p>
<p>默认情况下，连接工厂会假设RabbitMQ服务器监听localhost的5672端口，并且用户名和密码均为guest。对于开发来讲，这是合理的默认值，但是对于生产环境，我们可能希望修改这些默认值。如下 <code>&lt;connection-factory&gt;</code> 的设置重写了默认的做法：</p>
<p><img src="https://hexo-1300861231.cos.ap-shanghai.myqcloud.com/1584859042_20200322142643936_9596.png" alt></p>
<p>我们使用占位符来指定值，这样配置项可以在Spring配置文件之外进行管理（很可能位于属性文件中）。</p>
<p>除了连接工厂以外，我们还要考虑使用其他的几个配置元素。接下来，看一下如何创建队列、Exchange以及binding。</p>
<h2 id="声明队列、Exchange以及binding">声明队列、Exchange以及binding</h2>
<p>在JMS中，队列和主题的路由行为都是通过规范建立的，AMQP与之不同，它的路由更加丰富和灵活，依赖于如何定义队列和Exchange以及如何将它们绑定在一起。声明队列、Exchange和binding的一种方式是使用RabbitMQ Channel接口的各种方法。但是直接使用RabbitMQ的Channel接口非常麻烦。Spring AMQP能否帮助我们声明消息路由组件呢？</p>
<p>幸好，rabbit命名空间包含了多个元素，帮助我们声明队列、Exchange以及将它们结合在一起的binding。下表中列出了这些元素。</p>
<table>
<thead>
<tr>
<th>元　　素</th>
<th>作　　用</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>&lt;queue&gt;</code></td>
<td>创建一个队列</td>
</tr>
<tr>
<td><code>&lt;fanout-exchange&gt;</code></td>
<td>创建一个fanout类型的Exchange</td>
</tr>
<tr>
<td><code>&lt;header-exchange&gt;</code></td>
<td>创建一个header类型的Exchange</td>
</tr>
<tr>
<td><code>&lt;topic-exchange&gt;</code></td>
<td>创建一个topic类型的Exchange</td>
</tr>
<tr>
<td><code>&lt;direct-exchange&gt;</code></td>
<td>创建一个direct类型的Exchange</td>
</tr>
<tr>
<td><code> &lt;bindings&gt;&lt;binding/&gt;&lt;/bindings&gt;</code></td>
<td>元素定义一个或多个元素的集合。元素创建Exchange和队列之间的binding</td>
</tr>
</tbody>
</table>
<p>这些配置元素要与 <code>&lt;admin&gt;</code> 元素一起使用。 <code>&lt;admin&gt;</code> 元素会创建一个RabbitMQ管理组件（administrative component），它会自动创建（如果它们在RabbitMQ代理中尚未存在的话）上述这些元素所声明的队列、Exchange以及binding。</p>
<p>例如，如果你希望声明名为spittle.alert.queue的队列，只需要在Spring配置中添加如下的两个元素即可：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">admin</span> <span class="attr">connection-factory</span>=<span class="string">"connectionFactory"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">queue</span> <span class="attr">id</span>=<span class="string">"spittleAlertQueue"</span> <span class="attr">name</span>=<span class="string">"spittle.alerts"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>对于简单的消息来说，我们只需做这些就足够了。这是因为默认会有一个没有名称的direct Exchange，所有的队列都会绑定到这个Exchange上，并且routing key与队列的名称相同。在这个简单的配置中，我们可以将消息发送到这个没有名称的Exchange上，并将routing key设定为spittle.alert.queue，这样消息就会路由到这个队列中。实际上，我们重新创建了JMS的点对点模型。</p>
<p>但是，更加有意思的路由需要我们声明一个或更多的Exchange，并将其绑定到队列上。例如，如果要将消息路由到多个队列中，而不管routing key是什么，我们可以按照如下的方式配置一个fanout以及多个队列：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">admin</span> <span class="attr">connection-factory</span>=<span class="string">"connectionFactory"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">queue</span> <span class="attr">name</span>=<span class="string">"spittle.alert.queue.1"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">queue</span> <span class="attr">name</span>=<span class="string">"spittle.alert.queue.2"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">queue</span> <span class="attr">name</span>=<span class="string">"spittle.alert.queue.3"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">fanout-exchange</span> <span class="attr">name</span>=<span class="string">"spittle.fanout"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">bindings</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">binding</span> <span class="attr">queue</span>=<span class="string">"spittle.alert.queue.1"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">binding</span> <span class="attr">queue</span>=<span class="string">"spittle.alert.queue.2"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">binding</span> <span class="attr">queue</span>=<span class="string">"spittle.alert.queue.3"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">bindings</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">fanout-exchange</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>借助上表中的元素，会有无数种在RabbitMQ配置路由的方式，但是我却没有无尽的篇幅来为读者描述它们，所以为了让我们的讨论不至于偏离方向，我将这些创造性的路由作为练习留给读者，我将会继续讨论如何发送消息。</p>
<h2 id="使用RabbitTemplate发送消息">使用RabbitTemplate发送消息</h2>
<p>顾名思义，RabbitMQ连接工厂的作用是创建到RabbitMQ的连接。如果你希望通过RabbitMQ发送消息，那么你 <strong>可以</strong> 将connectionFactory bean注入到AlertServiceImpl类中，并使用它来创建Connection，使用这个Connection来创建Channel，然后使用这个Channel发布消息到Exchange上。</p>
<p>是的，你的确 <strong>可以</strong> 这样做。但是，如果这样做的话，你要做许多的工作并且会涉及到很多样板式代码。Spring所讨厌的一件事情就是样板式代码。我们已经看到Spring提供模板来消除样板式代码的多个例子——包括本章前面所介绍的JmsTemplate，它消除了JMS的样板式代码。因此，Spring AMQP提供RabbitTemplate来消除RabbitMQ发送和接收消息相关的样板式代码就一点也不让人感觉奇怪了。</p>
<p>配置RabbitTemplate的最简单方式是使用rabbit命名空间的 <code>&lt;template&gt;</code> 元素，如下所示：</p>
<p><img src="https://hexo-1300861231.cos.ap-shanghai.myqcloud.com/1584859041_20200322142643724_26928.png" alt></p>
<p>现在，要发送消息的话，我们只需要将模板bean注入到AlertServiceImpl中，并使用它来发送Spittle。如下的程序清单展现了一个新版本的AlertServiceImpl，它使用RabbitTemplate代替JmsTemplate来发送Spittle提醒。</p>
<p><img src="https://hexo-1300861231.cos.ap-shanghai.myqcloud.com/1584859041_20200322142643514_18977.png" alt></p>
<p>可以看到，现在sendSpittleAlert()调用RabbitTemplate的convertAndSend()方法，其中RabbitTemplate是被注入进来的。它传入了三个参数：Exchange的名称、routing key以及要发送的对象。注意，这里并 <strong>没有</strong> 指定消息该路由到何处、要发送给哪个队列以及期望哪个消费者来获取消息。</p>
<p>RabbitTemplate有多个重载版本的convertAndSend()方法，这些方法可以简化它的使用。例如，使用某个重载版本的convertAndSend()方法，我们可以在调用convertAndSend()的时候，不设置Exchange的名称：</p>
<p><img src="https://hexo-1300861231.cos.ap-shanghai.myqcloud.com/1584859041_20200322142643192_23962.png" alt></p>
<p>如果你愿意的话，还可以同时省略Exchange名称和routing key：</p>
<p><img src="https://hexo-1300861231.cos.ap-shanghai.myqcloud.com/1584859041_20200322142642981_13746.png" alt></p>
<p>如果在参数列表中省略Exchange名称，或者同时省略Exchange名称和routing key的话，RabbitTemplate将会使用默认的Exchange名称和routing key。按照我们之前的配置，默认的Exchange名称为空（或者说是默认没有名称的那一个Exchange），默认的routing key也为空。但是，我们可以在 <code>&lt;template&gt;</code> 元素上借助exchange和routing-key属性配置不同的默认值：</p>
<p><img src="https://hexo-1300861231.cos.ap-shanghai.myqcloud.com/1584859041_20200322142642773_10642.png" alt></p>
<p>不管设置的默认值是什么，我们都可以在调用convertAndSend()方法的时候，以参数的形式显式指定它们，从而覆盖掉默认值。</p>
<p>RabbitTemplate还有其他的方法来发送消息，你可能会对此感兴趣。例如，我们可以使用较低等级的send()方法来发送org.springframework.amqp.core.Message对象，如下所示：</p>
<p><img src="https://hexo-1300861231.cos.ap-shanghai.myqcloud.com/1584859040_20200322142642562_30572.png" alt></p>
<p>与convertAndSend()方法类似，send()方法也有重载形式，它们不需要提供Exchange名称和/或routing key。</p>
<p>使用send()方法的技巧在于构造要发送的Message对象。在这个“Hello World”样例中，我们通过给定字符串的字节数组来构建Message实例。对于String值来说，这足够了，但是如果消息的负载是复杂对象的话，那它就会复杂得多。</p>
<p>鉴于这种情况，我们有了convertAndSend()方法，它会自动将对象转换为Message。它需要一个消息转换器的帮助来完成该任务， <strong>默认的消息转换器是SimpleMessageConverter，它适用于String、Serializable实例以及字节数组。Spring AMQP还提供了其他几个有用的消息转换器，其中包括使用JSON和XML数据的消息转换器。</strong></p>
<p>现在，我们已经发送了消息，接下来我们转向回话的另外一端，看一下如何获取消息。</p>
<h2 id="使用RabbitTemplate同步接收AMQP消息">使用RabbitTemplate同步接收AMQP消息</h2>
<p>我们可以回忆一下，JMS提供了两种从队列中获取信息的方式：使用JmsTemplate的同步方式以及使用消息驱动POJO的异步方式。Spring AMQP提供了类似的方式来获取通过AMQP发送的消息。因为我们已经有了RabbitTemplate，所以首先看一下如何使用它同步地从队列中获取消息。</p>
<p>RabbitTemplate提供了多个接收信息的方法。最简单就是receive()方法，它位于消息的消费者端，对应于RabbitTemplate的send()方法。借助receive()方法，我们可以从队列中获取一个Message对象：</p>
<p><img src="https://hexo-1300861231.cos.ap-shanghai.myqcloud.com/1584859040_20200322142642352_10009.png" alt></p>
<p>或者，如果愿意的话，你还可以配置获取消息的默认队列，这是通过在配置模板的时候，设置queue属性实现的：</p>
<p><img src="https://hexo-1300861231.cos.ap-shanghai.myqcloud.com/1584859040_20200322142642141_20650.png" alt></p>
<p>这样的话，我们在调用receive()方法的时候，不需要设置任何参数就能从默认队列中获取消息了：</p>
<p><img src="https://hexo-1300861231.cos.ap-shanghai.myqcloud.com/1584859040_20200322142641930_18773.png" alt></p>
<p>在获取到Message对象之后，我们可能需要将它body属性中的字节数组转换为想要的对象。就像在发送的时候将领域对象转换为Message一样，将接收到的Message转换为领域对象同样非常繁琐。因此，我们可以考虑使用RabbitTemplate的receiveAndConvert()方法作为替代方案：</p>
<p><img src="https://hexo-1300861231.cos.ap-shanghai.myqcloud.com/1584859039_20200322142641722_10847.png" alt></p>
<p>我们还可以省略调用参数中的队列名称，这样它就会使用模板的默认队列名称：</p>
<p><img src="https://hexo-1300861231.cos.ap-shanghai.myqcloud.com/1584859039_20200322142641507_32456.png" alt></p>
<p>receiveAndConvert()方法会使用与sendAndConvert()方法相同的消息转换器，将Message对象转换为原始的类型。</p>
<p><strong>调用receive()和receiveAndConvert()方法都会立即返回，如果队列中没有等待的消息时，将会得到null。这就需要我们来管理轮询（polling）以及必要的线程，实现队列的监控。</strong></p>
<h2 id="使用消息驱动的AMQP-POJO">使用消息驱动的AMQP POJO</h2>
<p>我们并非必须同步轮询并等待消息到达，Spring AMQP还提供了消息驱动POJO的支持，这不禁使我们回忆起Spring JMS中的相同特性。让我们看一下如何通过消息驱动AMQP POJO的方式来接收消息。</p>
<p>如果你想在消息驱动POJO中异步地消费使用Spittle对象，首先要解决的问题就是这个POJO本身。如下的SpittleAlertHandler扮演了这个角色：</p>
<p><img src="https://hexo-1300861231.cos.ap-shanghai.myqcloud.com/1584859039_20200322142641297_22554.png" alt></p>
<p>注意，这个类与借助JMS消费Spittle时所用到SpittleAlertHandler完全一致。我们之所以能够重用相同的POJO是因为这个类丝毫没有依赖于JMS或AMQP，并且不管通过什么机制传递过来Spittle对象，它都能够进行处理。</p>
<p>我们还需要在Spring应用上下文中将SpittleAlertHandler声明为一个bean：</p>
<p><img src="https://hexo-1300861231.cos.ap-shanghai.myqcloud.com/1584859039_20200322142641083_15456.png" alt></p>
<p>同样，在使用基于JMS的MDP时，我们已经做过相同的事情，没有什么丝毫的差异。</p>
<p>最后，我们需要声明一个监听器容器和监听器，当消息到达的时候，能够调用SpittleAlertHandler。在基于JMS的MDP中，我们做过相同的事情，但是基于AMQP的MDP在配置上有一个细微的差别：</p>
<p><img src="https://hexo-1300861231.cos.ap-shanghai.myqcloud.com/1584859039_20200322142640874_30006.png" alt></p>
<p>你看到有什么差别了吗？我也同意这并不那么明显。 <code>&lt;listener-container&gt;</code> 与 <code>&lt;listener&gt;</code> 都与JMS对应的元素非常类似。但是， <strong>这些元素来自rabbit命名空间，而不是JMS命名空间</strong> 。我都说过了，没那么明显。</p>
<p>哦，还有一个细微的差别，我们不再通过destination属性（JMS中的做法）来监听队列或主题，这里我们通过queue-names属性来指定要监听的队列。但是，除此之外，基于AMQP的MDP与基于JMS的MDP都非常类似。</p>
<p>你可能也意识到了，queue-names属性的名称使用了复数形式。在这里我们只设定了一个要监听的队列，但是允许设置多个队列的名称，用逗号分割即可。</p>
<p>另外一种指定要监听队列的方法是引用 <code>&lt;queue&gt;</code> 元素所声明的队列bean。我们可以通过queues属性来进行设置：</p>
<p><img src="https://hexo-1300861231.cos.ap-shanghai.myqcloud.com/1584859038_20200322142640661_4320.png" alt></p>
<p>同样，这里可以接受逗号分割的queue ID列表。当然，这需要我们在声明队列的时候，为其指定ID。例如，如下是重新定义的提醒队列，这次指定了ID：</p>
<p><img src="https://hexo-1300861231.cos.ap-shanghai.myqcloud.com/1584859038_20200322142640341_5419.png" alt></p>
<p>注意，这里的id属性用来在Spring应用上下文中设置队列的bean ID，而name属性指定了RabbitMQ代理中队列的名称。</p>

      </div>
      
      
      
    </div>
    
  <ul class="breadcrumb">
          
            <li><a href="/quotes/">QUOTES</a></li>
            <li><a href="/quotes/Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">SPRING学习笔记</a></li>
            <li>51-SPRING消息</li>
          
  </ul>

    
    
    
  </div>


          </div>
          

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#null"><span class="nav-text">异步消息简介</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#发送消息"><span class="nav-text">发送消息</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#点对点消息模型"><span class="nav-text">点对点消息模型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#发布—订阅消息模型"><span class="nav-text">发布—订阅消息模型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#评估异步消息的优点"><span class="nav-text">评估异步消息的优点</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#无需等待"><span class="nav-text">无需等待</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#面向消息和解耦"><span class="nav-text">面向消息和解耦</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#位置独立"><span class="nav-text">位置独立</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#确保投递"><span class="nav-text">确保投递</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#null"><span class="nav-text">Spring JMS（ActiveMQ）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#搭建消息代理-ActiveMQ"><span class="nav-text">搭建消息代理-ActiveMQ</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#创建连接工厂-ActiveMQConnectionFactory"><span class="nav-text">创建连接工厂-ActiveMQConnectionFactory</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#声明ActiveMQ消息目的地-ActiveMQQueue、ActiveMQTopic"><span class="nav-text">声明ActiveMQ消息目的地-ActiveMQQueue、ActiveMQTopic</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用Spring的JMS模板消除重复代码"><span class="nav-text">使用Spring的JMS模板消除重复代码</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#处理失控的JMS代码"><span class="nav-text">处理失控的JMS代码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用JMS模版"><span class="nav-text">使用JMS模版</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用JmsTemplate发送消息"><span class="nav-text">使用JmsTemplate发送消息</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#设置默认目的地"><span class="nav-text">设置默认目的地</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#在发送时，对消息进行转换"><span class="nav-text">在发送时，对消息进行转换</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用JmsTemplate同步接收消息"><span class="nav-text">使用JmsTemplate同步接收消息</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用消息驱动的POJO"><span class="nav-text">使用消息驱动的POJO</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#创建消息监听器"><span class="nav-text">创建消息监听器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#配置消息监听器"><span class="nav-text">配置消息监听器</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用基于消息的RPC"><span class="nav-text">使用基于消息的RPC</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#导出基于JMS的服务"><span class="nav-text">导出基于JMS的服务</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用基于JMS的服务"><span class="nav-text">使用基于JMS的服务</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#null"><span class="nav-text">Spring AMQP（RabbitMQ）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#AMQP简介"><span class="nav-text">AMQP简介</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#什么是RabbitMQ"><span class="nav-text">什么是RabbitMQ</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#配置RabbitMQ连接工厂"><span class="nav-text">配置RabbitMQ连接工厂</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#声明队列、Exchange以及binding"><span class="nav-text">声明队列、Exchange以及binding</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用RabbitTemplate发送消息"><span class="nav-text">使用RabbitTemplate发送消息</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用RabbitTemplate同步接收AMQP消息"><span class="nav-text">使用RabbitTemplate同步接收AMQP消息</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用消息驱动的AMQP-POJO"><span class="nav-text">使用消息驱动的AMQP POJO</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <img class="site-author-image" itemprop="image" alt="jiateng.jiang"
    src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">jiateng.jiang</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">44</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">32</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">jiateng.jiang</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v4.0.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.4.2
  </div>

        












        
      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/pisces.js"></script>
<script src="/js/next-boot.js"></script>



  






  <script src="/js/local-search.js"></script>








<script>
if (document.querySelectorAll('div.pdf').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/pdfobject@2/pdfobject.min.js', () => {
    document.querySelectorAll('div.pdf').forEach(element => {
      PDFObject.embed(element.getAttribute('target'), element, {
        pdfOpenParams: {
          navpanes: 0,
          toolbar: 0,
          statusbar: 0,
          pagemode: 'thumbs',
          view: 'FitH'
        },
        PDFJS_URL: '/lib/pdf/web/viewer.html',
        height: element.getAttribute('height') || '100%'
      });
    });
  }, window.PDFObject);
}
</script>





  

  

  

</body>
</html>
