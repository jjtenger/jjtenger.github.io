<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '7.4.2',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: true,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"manual","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.json',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    },
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="在数据持久化的世界中，JDBC就像自行车。对于份内的工作，它能很好地完成并且在一些特定的场景下表现出色。但随着应用程序变得越来越复杂，对持久化的需求也变得更复杂。我们需要将对象的属性映射到数据库的列上，并且需要自动生成语句和查询，这样我们就能从无休止的问号字符串中解脱出来。此外，我们还需要一些更复杂的特性：">
<meta property="og:type" content="website">
<meta property="og:title" content="JJT-个人Wiki">
<meta property="og:url" content="https:&#x2F;&#x2F;hexo-pages-1300861231.cos-website.ap-shanghai.myqcloud.com&#x2F;quotes&#x2F;Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0&#x2F;44-SpringORM.html">
<meta property="og:site_name" content="JJT-个人Wiki">
<meta property="og:description" content="在数据持久化的世界中，JDBC就像自行车。对于份内的工作，它能很好地完成并且在一些特定的场景下表现出色。但随着应用程序变得越来越复杂，对持久化的需求也变得更复杂。我们需要将对象的属性映射到数据库的列上，并且需要自动生成语句和查询，这样我们就能从无休止的问号字符串中解脱出来。此外，我们还需要一些更复杂的特性：">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https:&#x2F;&#x2F;hexo-1300861231.cos.ap-shanghai.myqcloud.com&#x2F;1584813108_20200322014426153_27453.jpg">
<meta property="og:image" content="https:&#x2F;&#x2F;hexo-1300861231.cos.ap-shanghai.myqcloud.com&#x2F;1584813107_20200322014425637_22810.png">
<meta property="og:image" content="https:&#x2F;&#x2F;hexo-1300861231.cos.ap-shanghai.myqcloud.com&#x2F;1584813105_20200322014425221_11099.png">
<meta property="og:image" content="https:&#x2F;&#x2F;hexo-1300861231.cos.ap-shanghai.myqcloud.com&#x2F;1584813105_20200322014424806_12003.png">
<meta property="og:image" content="https:&#x2F;&#x2F;hexo-1300861231.cos.ap-shanghai.myqcloud.com&#x2F;1584813102_20200322014424496_26512.jpg">
<meta property="og:image" content="https:&#x2F;&#x2F;hexo-1300861231.cos.ap-shanghai.myqcloud.com&#x2F;1584813101_20200322014423870_14257.png">
<meta property="og:image" content="https:&#x2F;&#x2F;hexo-1300861231.cos.ap-shanghai.myqcloud.com&#x2F;1584813100_20200322014423658_21141.png">
<meta property="og:image" content="https:&#x2F;&#x2F;hexo-1300861231.cos.ap-shanghai.myqcloud.com&#x2F;1584813099_20200322014423238_20822.png">
<meta property="og:image" content="https:&#x2F;&#x2F;hexo-1300861231.cos.ap-shanghai.myqcloud.com&#x2F;1584813098_20200322014422924_6565.png">
<meta property="og:image" content="https:&#x2F;&#x2F;hexo-1300861231.cos.ap-shanghai.myqcloud.com&#x2F;1584813097_20200322014422507_28574.png">
<meta property="og:image" content="https:&#x2F;&#x2F;hexo-1300861231.cos.ap-shanghai.myqcloud.com&#x2F;1584813096_20200322014422192_14195.png">
<meta property="og:image" content="https:&#x2F;&#x2F;hexo-1300861231.cos.ap-shanghai.myqcloud.com&#x2F;1584813096_20200322014421774_6910.png">
<meta property="og:image" content="https:&#x2F;&#x2F;hexo-1300861231.cos.ap-shanghai.myqcloud.com&#x2F;1584813095_20200322014421565_9064.png">
<meta property="og:image" content="https:&#x2F;&#x2F;hexo-1300861231.cos.ap-shanghai.myqcloud.com&#x2F;1584813093_20200322014421248_18618.jpg">
<meta property="og:image" content="https:&#x2F;&#x2F;hexo-1300861231.cos.ap-shanghai.myqcloud.com&#x2F;1584813090_20200322014420727_9944.jpg">
<meta property="og:image" content="https:&#x2F;&#x2F;hexo-1300861231.cos.ap-shanghai.myqcloud.com&#x2F;1584813089_20200322014420308_25265.png">
<meta property="og:image" content="https:&#x2F;&#x2F;hexo-1300861231.cos.ap-shanghai.myqcloud.com&#x2F;1584813089_20200322014420098_849.png">
<meta property="og:image" content="https:&#x2F;&#x2F;hexo-1300861231.cos.ap-shanghai.myqcloud.com&#x2F;1584813088_20200322014419789_7469.png">
<meta property="og:image" content="https:&#x2F;&#x2F;hexo-1300861231.cos.ap-shanghai.myqcloud.com&#x2F;1584813087_20200322014419376_14389.png">
<meta property="og:image" content="https:&#x2F;&#x2F;hexo-1300861231.cos.ap-shanghai.myqcloud.com&#x2F;1584813087_20200322014419059_7019.png">
<meta property="og:image" content="https:&#x2F;&#x2F;hexo-1300861231.cos.ap-shanghai.myqcloud.com&#x2F;1584813086_20200322014418548_27446.png">
<meta property="og:image" content="https:&#x2F;&#x2F;hexo-1300861231.cos.ap-shanghai.myqcloud.com&#x2F;1584813085_20200322014418238_28595.png">
<meta property="og:image" content="https:&#x2F;&#x2F;hexo-1300861231.cos.ap-shanghai.myqcloud.com&#x2F;1584813085_20200322014417927_3704.png">
<meta property="og:image" content="https:&#x2F;&#x2F;hexo-1300861231.cos.ap-shanghai.myqcloud.com&#x2F;1584813084_20200322014417616_19001.png">
<meta property="og:image" content="https:&#x2F;&#x2F;hexo-1300861231.cos.ap-shanghai.myqcloud.com&#x2F;1584813084_20200322014417404_10332.png">
<meta property="og:image" content="https:&#x2F;&#x2F;hexo-1300861231.cos.ap-shanghai.myqcloud.com&#x2F;1584813084_20200322014417095_14881.png">
<meta property="og:image" content="https:&#x2F;&#x2F;hexo-1300861231.cos.ap-shanghai.myqcloud.com&#x2F;1584813083_20200322014416784_27716.png">
<meta property="og:image" content="https:&#x2F;&#x2F;hexo-1300861231.cos.ap-shanghai.myqcloud.com&#x2F;1584813083_20200322014416474_20056.png">
<meta property="og:image" content="https:&#x2F;&#x2F;hexo-1300861231.cos.ap-shanghai.myqcloud.com&#x2F;1584813082_20200322014416062_28879.png">
<meta property="og:image" content="https:&#x2F;&#x2F;hexo-1300861231.cos.ap-shanghai.myqcloud.com&#x2F;1584813081_20200322014415752_14374.png">
<meta property="og:image" content="https:&#x2F;&#x2F;hexo-1300861231.cos.ap-shanghai.myqcloud.com&#x2F;1584813080_20200322014415543_3938.jpg">
<meta property="og:image" content="https:&#x2F;&#x2F;hexo-1300861231.cos.ap-shanghai.myqcloud.com&#x2F;1584813080_20200322014415129_24477.png">
<meta property="og:image" content="https:&#x2F;&#x2F;hexo-1300861231.cos.ap-shanghai.myqcloud.com&#x2F;1584813080_20200322014414820_10739.png">
<meta property="og:image" content="https:&#x2F;&#x2F;hexo-1300861231.cos.ap-shanghai.myqcloud.com&#x2F;1584813079_20200322014414609_12885.png">
<meta property="og:image" content="https:&#x2F;&#x2F;hexo-1300861231.cos.ap-shanghai.myqcloud.com&#x2F;1584813078_20200322014414393_1910.png">
<meta property="og:updated_time" content="2020-12-15T11:07:33.040Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https:&#x2F;&#x2F;hexo-1300861231.cos.ap-shanghai.myqcloud.com&#x2F;1584813108_20200322014426153_27453.jpg">

<link rel="canonical" href="https://hexo-pages-1300861231.cos-website.ap-shanghai.myqcloud.com/quotes/Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/44-SpringORM">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: false,
    isPage: true,
    isArchive: false
  };
</script>

  <title> | JJT-个人Wiki
  </title>
  








  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">JJT-个人Wiki</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">you see see you one day day</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="搜索..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
  
  

          <div class="content">
            

  <div class="posts-expand">
    
    
    
    <div class="post-block" lang="zh-CN">
      <header class="post-header">

<h1 class="post-title" itemprop="name headline">
</h1>

<div class="post-meta">
  
  <ul class="breadcrumb">
          
            <li><a href="/quotes/">QUOTES</a></li>
            <li><a href="/quotes/Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">SPRING学习笔记</a></li>
            <li>44-SPRINGORM</li>
          
  </ul>

</div>

</header>

      
      
      
      <div class="post-body">
          <p>在数据持久化的世界中，JDBC就像自行车。对于份内的工作，它能很好地完成并且在一些特定的场景下表现出色。但随着应用程序变得越来越复杂，对持久化的需求也变得更复杂。我们需要将对象的属性映射到数据库的列上，并且需要自动生成语句和查询，这样我们就能从无休止的问号字符串中解脱出来。此外，我们还需要一些更复杂的特性：</p><a id="more"></a>
<ul>
<li>
<p>延迟加载（<em>Lazy loading</em>）：随着我们的对象关系变得越来越复杂，有时候我们并不希望立即获取完整的对象间关系。举一个典型的例子，假设我们在查询一组PurchaseOrder对象，而每个对象中都包含一个LineItem对象集合。如果我们只关心PurchaseOrder的属性，那查询出LineItem的数据就毫无意义。而且这可能是开销很大的操作。延迟加载允许我们只在需要的时候获取数据。</p>
</li>
<li>
<p>预先抓取（<em>Eager fetching</em>）：这与延迟加载是相对的。借助于预先抓取，我们可以使用一个查询获取完整的关联对象。如果我们需要PurchaseOrder及其关联的LineItem对象，预先抓取的功能可以在一个操作中将它们全部从数据库中取出来，节省了多次查询的成本。</p>
</li>
<li>
<p>级联（<em>Cascading</em>）：有时，更改数据库中的表会同时修改其他表。回到我们订购单的例子中，当删除Order对象时，我们希望同时在数据库中删除关联的LineItem。</p>
</li>
</ul>
<p>一些可用的框架提供了这样的服务，这些服务的通用名称是对象/关系映射（object-relational mapping，ORM）。在持久层使用ORM工具，可以节省数千行的代码和大量的开发时间。ORM工具能够把你的注意力从容易出错的SQL代码转向如何实现应用程序的真正需求。</p>
<p>Spring对多个持久化框架都提供了支持，包括Hibernate、iBATIS、Java数据对象（Java Data Objects，JDO）以及Java持久化API（Java Persistence API，JPA）。与Spring对JDBC的支持那样，Spring对ORM框架的支持提供了与这些框架的集成点以及一些附加的服务：</p>
<ul>
<li>支持集成Spring声明式事务；</li>
<li>透明的异常处理；</li>
<li>线程安全的、轻量级的模板类；</li>
<li>DAO支持类；</li>
<li>资源管理。</li>
</ul>
<p>Spring对不同ORM解决方案的支持是很相似的。一旦掌握了Spring对某种ORM框架的支持后，你可以轻松地切换到另一个框架。</p>
<h1>Spring集成Hibernate</h1>
<h2 id="声明Hibernate的Session工厂">声明Hibernate的Session工厂</h2>
<p>使用Hibernate所需的主要接口是org.hibernate.Session。<strong>Session接口</strong>提供了基本的数据访问功能，如保存、更新、删除以及从数据库加载对象的功能。通过Hibernate的Session接口，应用程序的Repository能够满足所有的持久化需求。</p>
<p>获取Hibernate Session对象的标准方式是借助于Hibernate <strong>SessionFactory接口</strong>的实现类。除了一些其他的任务，SessionFactory主要负责Hibernate Session的打开、关闭以及管理。</p>
<p>在Spring中，我们要通过Spring的某一个Hibernate Session工厂bean来获取Hibernate SessionFactory。从3.1版本开始，Spring提供了三个Session工厂bean供我们选择：</p>
<ul>
<li>org.springframework.orm.hibernate3.LocalSessionFactoryBean</li>
<li>org.springframework.orm.hibernate3.annotation.AnnotationSessionFactoryBean</li>
<li>org.springframework.orm.hibernate4.LocalSessionFactoryBean</li>
</ul>
<p>这些Session工厂bean都是Spring FactoryBean接口的实现，它们会产生一个<strong>HibernateSessionFactory</strong>，它能够装配进任何SessionFactory类型的属性中。这样的话，就能在应用的Spring上下文中，与其他的bean一起配置Hibernate Session工厂。</p>
<p>至于选择使用哪一个Session工厂，这取决于使用哪个版本的Hibernate以及你使用XML还是使用注解来定义对象-数据库之间的映射关系。<strong>如果你使用Hibernate 3.2或更高版本（直到Hibernate 4.0，但不包含这个版本）并且使用XML定义映射的话，那么你需要定义Spring的org.springframework.orm.hibernate3包中的LocalSessionFactoryBean</strong>：</p>
<p><img src="https://hexo-1300861231.cos.ap-shanghai.myqcloud.com/1584813108_20200322014426153_27453.jpg" alt></p>
<p>在配置LocalSessionFactoryBean时，我们使用了三个属性。<strong>属性dataSource</strong>装配了一个DataSource bean的引用。<strong>属性mappingResources</strong>列出了一个或多个的Hibernate映射文件，在这些文件中定义了应用程序的持久化策略。最后，<strong>hibernateProperties属性</strong>配置了Hibernate如何进行操作的细节。在本示例中，我们配置Hibernate使用H2数据库并且要按照H2Dialect来构建SQL。</p>
<p><strong>如果你更倾向于使用注解的方式来定义持久化，并且你还没有使用Hibernate 4的话，那么需要使用AnnotationSessionFactoryBean来代替LocalSessionFactoryBean</strong>：</p>
<p><img src="https://hexo-1300861231.cos.ap-shanghai.myqcloud.com/1584813107_20200322014425637_22810.png" alt></p>
<p><strong>如果你使用Hibernate 4的话，那么就应该使用org.springframework.orm.hibernate4中的LocalSessionFactoryBean</strong>。尽管它与Hibernate 3包中的LocalSessionFactoryBean使用了相同的名称，但是Spring 3.1新引入的这个Session工厂类似于Hibernate 3中<strong>LocalSessionFactoryBean和AnnotationSessionFactoryBean的结合体。它有很多相同的属性，能够支持基于XML的映射和基于注解的映射</strong>。如下的代码展现了如何对它进行配置，使其支持基于注解的映射：</p>
<p><img src="https://hexo-1300861231.cos.ap-shanghai.myqcloud.com/1584813105_20200322014425221_11099.png" alt></p>
<p>在这两个配置中，<strong>dataSource和hibernateProperties属性</strong>都声明了从哪里获取数据库连接以及要使用哪一种数据库。这里不再列出Hibernate配置文件，而是<strong>使用packagesToScan属性告诉Spring扫描一个或多个包以查找域类，这些类通过注解的方式表明要使用Hibernate进行持久化，这些类可以使用的注解包括JPA的@Entity或@MappedSuperclass以及Hibernate的@Entity。</strong></p>
<p>如果愿意的话，你还可以使用<strong>annotatedClasses属性</strong>来将应用程序中所有的持久化类以全限定名的方式明确列出：</p>
<p><img src="https://hexo-1300861231.cos.ap-shanghai.myqcloud.com/1584813105_20200322014424806_12003.png" alt></p>
<p>annotatedClasses属性对于准确指定少量的域类是不错的选择。如果你有很多的域类并且不想将其全部列出，又或者你想自由地添加或移除域类而不想修改Spring配置的话，那使用packagesToScan属性是更合适的。</p>
<p>在Spring应用上下文中配置完Hibernate的Session工厂bean后，那我们就可以创建自己的Repository类了。</p>
<h2 id="自动注入SessionFactory实现非耦合的Hibernate编程">自动注入SessionFactory实现非耦合的Hibernate编程</h2>
<p>在Spring和Hibernate的早期岁月中，编写Repository类将会涉及到使用Spring的HibernateTemplate。HibernateTemplate能够保证每个事务使用同一个Session。但是这种方式的弊端在于我们的Repository实现会直接与Spring耦合。</p>
<p>现在的最佳实践是不再使用HibernateTemplate，而是使用上下文Session（Contextual session）。通过这种方式，会<strong>直接将Hibernate</strong> <strong>SessionFactory装配到Repository中，并使用它来获取Session</strong>，如下面的程序清单所示。</p>
<p><img src="https://hexo-1300861231.cos.ap-shanghai.myqcloud.com/1584813102_20200322014424496_26512.jpg" alt></p>
<p>在程序清单中有几个地方需要注意。首先，我们通过@Inject注解让Spring自动将一个SessionFactory注入到HibernateSpitterRepository的sessionFactory属性中。接下来，<strong>在currentSession()方法中，我们使用这个SessionFactory来获取当前事务的Session。</strong></p>
<p>另外需要注意的是，我们在类上使用了 <strong>@Repository注解</strong> ，这会为我们做两件事情。首先，@Repository是Spring的另一种构造性注解，它能够像其他注解一样被Spring的组件扫描所扫描到。这样就不必明确声明HibernateSpitterRepository bean了，只要这个Repository类在组件扫描所涵盖的包中即可。</p>
<p>除了帮助减少显式配置以外，@Repository还有另外一个用处。让我们回想一下模板类，它有一项任务就是捕获平台相关的异常，然后使用Spring统一非检查型异常的形式重新抛出。如果我们使用Hibernate上下文Session而不是Hibernate模板的话，那异常转换会怎么处理呢？</p>
<p><strong>为了给不使用模板的Hibernate Repository添加异常转换功能，我们只需在Spring应用上下文中添加一个PersistenceExceptionTranslationPostProcessor</strong> <strong>bean</strong>：</p>
<p><img src="https://hexo-1300861231.cos.ap-shanghai.myqcloud.com/1584813101_20200322014423870_14257.png" alt></p>
<p>PersistenceExceptionTranslationPostProcessor是一个bean 后置处理器（bean post-processor），它会在所有拥有@Repository注解的类上添加一个通知器（advisor），这样就会捕获任何平台相关的异常并以Spring非检查型数据访问异常的形式重新抛出。</p>
<p>现在，Hibernate版本的Repository已经完成了。我们开发时，没有依赖Spring的特定类（除了@Repository注解以外）。这种不使用模板的方式也适用于开发纯粹的基于JPA的Repository，让我们再尝试开发另一个SpitterRepository实现类，这次我们使用的是JPA。</p>
<h1>Spring集成JPA</h1>
<p>Java持久化API（Java Persistence API，JPA）诞生在EJB 2实体Bean的废墟之上，并成为下一代Java持久化标准。JPA是基于POJO的持久化机制，它从Hibernate和Java数据对象（Java Data Object，JDO）上借鉴了很多理念并加入了Java 5注解的特性。</p>
<p>在Spring 2.0版本中，Spring首次集成了JPA的功能。具有讽刺意味的是，很多人批评（或赞赏）Spring颠覆了EJB。但是，当Spring支持JPA后，很多开发人员都推荐在基于Spring的应用程序中使用JPA实现持久化。实际上，有些人还将Spring-JPA的组合称为POJO开发的梦之队。</p>
<p>在Spring中使用JPA的第一步是要在Spring应用上下文中将实体管理器工厂（entity manager factory）按照bean的形式来进行配置。</p>
<h2 id="EntityManagerFactory配置及注入">EntityManagerFactory配置及注入</h2>
<p>简单来讲，基于JPA的应用程序需要使用EntityManagerFactory的实现类来获取EntityManager实例。JPA定义了两种类型的实体管理器：</p>
<ul>
<li><strong>应用程序管理类型（Application-managed）</strong>：当应用程序向实体管理器工厂直接请求实体管理器时，<strong>实体管理器工厂直接创建一个实体管理器</strong>。在这种模式下，程序要负责打开或关闭实体管理器并在事务中对其进行控制。这种方式的实体管理器适合于不运行在Java EE容器中的独立应用程序。</li>
<li><strong>容器管理类型（Container-managed）</strong>：<strong>实体管理器由Java EE创建和管理。应用程序根本不与实体管理器工厂打交道。相反，实体管理器直接通过注入或JNDI来获取</strong>。容器负责配置实体管理器工厂。这种类型的实体管理器最适用于Java EE容器，在这种情况下会希望在persistence.xml指定的JPA配置之外保持一些自己对JPA的控制。</li>
</ul>
<p>以上的两种实体管理器实现了<strong>同一个EntityManager接口。关键的区别不在于EntityManager本身，而是在于EntityManager的创建和管理方式</strong>。应用程序管理类型的EntityManager是由EntityManagerFactory创建的，而后者是通过PersistenceProvider的createEntityManagerFactory()方法得到的。与此相对，容器管理类型的Entity ManagerFactory是通过PersistenceProvider的createContainerEntityManager Factory()方法获得的。</p>
<p>这对想使用JPA的Spring开发者来说又意味着什么呢？其实这并没太大的关系。不管你希望使用哪种EntityManagerFactory，Spring都会负责管理EntityManager。<strong>如果你使用的是应用程序管理类型的实体管理器，Spring承担了应用程序的角色并以透明的方式处理EntityManager。在容器管理的场景下，Spring会担当容器的角色。</strong></p>
<p>这两种实体管理器工厂分别由对应的Spring工厂Bean创建：</p>
<ul>
<li><strong>LocalEntityManagerFactoryBean</strong>生成应用程序管理类型的EntityManagerFactory；</li>
<li><strong>LocalContainerEntityManagerFactoryBean</strong>生成容器管理类型的EntityManagerFactory。</li>
</ul>
<p>需要说明的是，选择应用程序管理类型的还是容器管理类型的EntityManager Factory，对于基于Spring的应用程序来讲是完全透明的。当组合使用Spring和JPA时，处理EntityManagerFactory的复杂细节被隐藏了起来，数据访问代码只需关注它们的真正目标即可，也就是数据访问。</p>
<p>应用程序管理类型和容器管理类型的实体管理器工厂之间唯一值得关注的区别是在Spring应用上下文中如何进行配置。让我们先看看如何在Spring中配置应用程序管理类型的LocalEntityManagerFactoryBean，然后再看看如何配置容器管理类型的LocalContainerEntityManagerFactoryBean。</p>
<h3 id="配置应用程序管理类型的EntityManagerFactory">配置应用程序管理类型的EntityManagerFactory</h3>
<p>对于应用程序管理类型的实体管理器工厂来说，它绝大部分配置信息来源于一个名为persistence.xml的配置文件。这个文件必须位于类路径下的META-INF目录下。</p>
<p>persistence.xml的作用在于定义一个或多个持久化单元。持久化单元是同一个数据源下的一个或多个持久化类。简单来讲，<strong>persistence.xml列出了一个或多个的持久化类以及一些其他的配置如数据源和基于XML的配置文件</strong>。如下是一个典型的persistence.xml文件，它是用于Spittr应用程序的：</p>
<p><img src="https://hexo-1300861231.cos.ap-shanghai.myqcloud.com/1584813100_20200322014423658_21141.png" alt></p>
<p>因为在persistence.xml文件中包含了大量的配置信息，所以在Spring中需要配置的就很少了。可以通过以下的@Bean注解方法在Spring中<strong>声明LocalEntityManagerFactoryBean</strong>：</p>
<p><img src="https://hexo-1300861231.cos.ap-shanghai.myqcloud.com/1584813099_20200322014423238_20822.png" alt></p>
<p>赋给persistenceUnitName属性的值就是persistence.xml中持久化单元的名称。</p>
<p>创建应用程序管理类型的EntityManagerFactory都是在persistence.xml中进行的，而这正是应用程序管理的本意。在应用程序管理的场景下（不考虑Spring时），完全由应用程序本身来负责获取EntityManagerFactory，这是通过JPA实现的PersistenceProvider做到的。如果每次请求EntityManagerFactory时都需要定义持久化单元，那代码将会迅速膨胀。通过将其配置在persistence.xml中，JPA就能够在这个特定的位置查找持久化单元定义了。</p>
<h3 id="配置容器管理类型的EntityManagerFactory">配置容器管理类型的EntityManagerFactory</h3>
<p>容器管理的JPA采取了一个不同的方式。当运行在容器中时，可以使用容器（在我们的场景下是Spring）提供的信息来生成EntityManagerFactory。</p>
<p>你可以将数据源信息配置在Spring应用上下文中，而不是在persistence.xml中了。例如，如下的@Bean注解方法声明了在Spring中如何使用<strong>LocalContainerEntityManagerFactoryBean</strong>来配置容器管理类型的JPA：</p>
<p><img src="https://hexo-1300861231.cos.ap-shanghai.myqcloud.com/1584813098_20200322014422924_6565.png" alt></p>
<p>这里，我们使用了Spring配置的数据源来设置dataSource属性。任何javax.sql.DataSource的实现都是可以的。尽管数据源还可以在persistence.xml中进行配置，但是<strong>这个属性指定的数据源具有更高的优先级</strong>。</p>
<p><strong>jpaVendorAdapter属性用于指明所使用的是哪一个厂商的JPA实现</strong>。Spring提供了多个JPA厂商适配器：</p>
<ul>
<li>EclipseLinkJpaVendorAdapter</li>
<li>HibernateJpaVendorAdapter</li>
<li>OpenJpaVendorAdapter</li>
<li>TopLinkJpaVendorAdapter（在Spring 3.1版本中，已经将其废弃了）</li>
</ul>
<p>在本例中，我们使用Hibernate作为JPA实现，所以将其配置为Hibernate-JpaVendorAdapter：</p>
<p><img src="https://hexo-1300861231.cos.ap-shanghai.myqcloud.com/1584813097_20200322014422507_28574.png" alt></p>
<p>有多个属性需要设置到厂商适配器上，但是最重要的是database属性，在上面我们设置了要使用的数据库是Hypersonic。这个属性支持的其他值如表所示。</p>
<table>
<thead>
<tr>
<th>数据库平台</th>
<th>属性database的值</th>
</tr>
</thead>
<tbody>
<tr>
<td>IBM DB2</td>
<td>DB2</td>
</tr>
<tr>
<td>Apache Derby</td>
<td>DERBY</td>
</tr>
<tr>
<td>H2</td>
<td>H2</td>
</tr>
<tr>
<td>Hypersonic</td>
<td>HSQL</td>
</tr>
<tr>
<td>Informix</td>
<td>INFORMIX</td>
</tr>
<tr>
<td>MySQL</td>
<td>MYSQL</td>
</tr>
<tr>
<td>Oracle</td>
<td>ORACLE</td>
</tr>
<tr>
<td>PostgresQL</td>
<td>POSTGRESQL</td>
</tr>
<tr>
<td>Microsoft SQL Server</td>
<td>SQLSERVER</td>
</tr>
<tr>
<td>Sybase</td>
<td>SYBASE</td>
</tr>
</tbody>
</table>
<p>一些特定的动态持久化功能需要对持久化类按照指令（instrumentation）进行修改才能支持。在属性延迟加载（只在它们被实际访问时才从数据库中获取）的对象中，必须要包含知道如何查询未加载数据的代码。一些框架使用动态代理实现延迟加载，而有一些框架像JDO，则是在编译时执行类指令。</p>
<p>选择哪一种实体管理器工厂主要取决于如何使用它。但是，下面的小技巧可能会让你更加倾向于使用LocalContainerEntityManagerFactoryBean。</p>
<p>persistence.xml文件的主要作用就在于识别持久化单元中的实体类。但是从Spring 3.1开始，我们能够在LocalContainerEntityManagerFactoryBean中<strong>直接设置packagesToScan属性</strong>：</p>
<p><img src="https://hexo-1300861231.cos.ap-shanghai.myqcloud.com/1584813096_20200322014422192_14195.png" alt></p>
<p>在这个配置中，LocalContainerEntityManagerFactoryBean会扫描com.habuma.spittr.domain包，查找带有@Entity注解的类。因此，没有必要在persistence.xml文件中进行声明了。同时，因为DataSource也是注入到LocalContainerEntityManager FactoryBean中的，所以也没有必要在persistence.xml文件中配置数据库信息了。那么结论就是，<strong>persistence.xml文件完全没有必要存在了</strong>！你尽可以将其删除，让LocalContainerEntityManagerFactoryBean来处理这些事情。</p>
<h3 id="从JNDI获取EntityManagerFactory">从JNDI获取EntityManagerFactory</h3>
<p>如果将Spring应用程序部署在应用服务器中时，EntityManagerFactory已经创建好了并且位于JNDI中等待查询使用。在这种情况下，可以使用Spring jee命名空间下的 <code>&lt;jee:jndi-lookup&gt;</code> 元素来获取对EntityManagerFactory的引用：</p>
<p><img src="https://hexo-1300861231.cos.ap-shanghai.myqcloud.com/1584813096_20200322014421774_6910.png" alt></p>
<p>我们也可以使用如下的Java配置来获取EntityManagerFactory：</p>
<p><img src="https://hexo-1300861231.cos.ap-shanghai.myqcloud.com/1584813095_20200322014421565_9064.png" alt></p>
<p>尽管这种方法没有返回EntityManagerFactory，但是它的结果就是一个EntityManagerFactory bean。这是因为它所<strong>返回的JndiObjectFactoryBean是FactoryBean接口的实现，它能够创建EntityManagerFactory</strong>。</p>
<p>不管你采用何种方式得到EntityManagerFactory，一旦得到这样的对象，接下来就可以编写Repository了。</p>
<h3 id="自动注入EntityManagerFactory实现非耦合的JPA编程">自动注入EntityManagerFactory实现非耦合的JPA编程</h3>
<p>正如Spring对其他持久化方案的集成一样，Spring对JPA集成也提供了JpaTemplate模板以及对应的支持类JpaDaoSupport。但是，为了实现更纯粹的JPA方式，基于模板的JPA已经被弃用了。这与我们之前使用的Hibernate上下文Session是很类似的。</p>
<p>鉴于纯粹的JPA方式远胜于基于模板的JPA，所以在本节中我们将会重点关注如何构建不依赖Spring的JPA Repository。如下程序清单中的JpaSpitterRepository展现了如何开发不使用Spring JpaTemplate的JPA Repository。</p>
<p><img src="https://hexo-1300861231.cos.ap-shanghai.myqcloud.com/1584813093_20200322014421248_18618.jpg" alt></p>
<p>程序清单中，需要注意的是EntityManagerFactory属性，它使用了 <strong>@PersistenceUnit注解</strong> ，因此，Spring会将EntityManagerFactory注入到Repository之中。有了EntityManagerFactory之后，JpaSpitterRepository的方法就能使用它来创建EntityManager了，然后EntityManager可以针对数据库执行操作。</p>
<p>在JpaSpitterRepository中，唯一的问题在于每个方法都会调用createEntityManager()。除了引入易出错的重复代码以外，这还意味着每次调用Repository的方法时，都会创建一个新的EntityManager。这种复杂性源于事务。如果我们能够预先准备好EntityManager，那会不会更加方便呢？</p>
<p>这里的问题在于EntityManager并不是线程安全的，一般来讲并不适合注入到像Repository这样共享的单例bean中。但是，这并不意味着我们没有办法要求注入EntityManager。如下的程序清单展现了如何借助 <strong>@PersistentContext注解</strong> 为JpaSpitterRepository设置EntityManager。</p>
<p><img src="https://hexo-1300861231.cos.ap-shanghai.myqcloud.com/1584813090_20200322014420727_9944.jpg" alt></p>
<p>在这个新版本的JpaSpitterRepository中，直接为其设置了EntityManager，这样的话，在每个方法中就没有必要再通过EntityManagerFactory创建EntityManager了。尽管这种方式非常便利，但是你可能会担心注入的EntityManager会有线程安全性的问题。</p>
<p>这里的真相是@PersistenceContext并不会真正注入EntityManager——至少，精确来讲不是这样的。<strong>它没有将真正的EntityManager设置给Repository，而是给了它一个EntityManager的代理。真正的EntityManager是与当前事务相关联的那一个，如果不存在这样的EntityManager的话，就会创建一个新的</strong>。这样的话，我们就能始终以线程安全的方式使用实体管理器。</p>
<p>另外，还需要了解@PersistenceUnit和@PersistenceContext并不是Spring的注解，它们是由JPA规范提供的。为了让Spring理解这些注解，并注入EntityManagerFactory或EntityManager，我们<strong>必须要配置Spring的PersistenceAnnotationBeanPostProcessor</strong>。如果你已经使用了 <code>&lt;context:annotation-config&gt;</code> 或 <code>&lt;context:component-scan&gt;</code> ，那么你就不必再担心了，因为这些配置元素会自动注册PersistenceAnnotationBeanPostProcessor bean。否则的话，我们需要显式地注册这个bean：</p>
<p><img src="https://hexo-1300861231.cos.ap-shanghai.myqcloud.com/1584813089_20200322014420308_25265.png" alt></p>
<p>你可能也注意到了JpaSpitterRepository使用了@Repository和@Transactional注解。 <strong>@Transactional</strong> 表明这个Repository中的持久化方法是在事务上下文中执行的。</p>
<p>对于@Repository注解，它的作用与开发Hibernate上下文Session版本的Repository时是一致的。由于没有使用模板类来处理异常，所以我们需要为Repository添加@Repository注解，这样PersistenceExceptionTranslationPostProcessor就会知道要将这个bean产生的异常转换成Spring的统一数据访问异常。既然提到了PersistenceExceptionTranslationPostProcessor，要记住的是我们需要将其作为一个bean装配到Spring中，就像我们在Hibernate样例中所做的那样。</p>
<p>提醒一下，不管对于JPA还是Hibernate，异常转换都不是强制要求的。如果你希望在Repository中抛出特定的JPA或Hibernate异常，只需将PersistenceExceptionTranslationPostProcessor省略掉即可，这样原来的异常就会正常地处理。但是，如果使用了Spring的异常转换，你会将所有的数据访问异常置于Spring的体系之下，这样以后切换持久化机制的话会更容易。</p>
<h1>自动化的JPARepository实现</h1>
<h2 id="自动生成JPARepository接口实现">自动生成JPARepository接口实现</h2>
<p>直接与EntityManager交互来查询数据库的代码仍然多少还是样板式的。例如，让我们重新审视addSpitter()方法：</p>
<p><img src="https://hexo-1300861231.cos.ap-shanghai.myqcloud.com/1584813089_20200322014420098_849.png" alt></p>
<p>在任何具有一定规模的应用中，你可能会以几乎完全相同的方式多次编写这种方法。实际上，除了所持久化的Spitter对象不同以外，我敢打赌你以前肯定写过类似的方法。其实，JpaSpitterRepository中的其他方法也没有什么太大的创造性。领域对象会有所不同，但是所有Repository中的方法都是很通用的。</p>
<p>为什么我们需要一遍遍地编写相同的持久化方法呢，难道仅仅是因为要处理的领域类型不同吗？Spring Data JPA能够终结这种样板式的愚蠢行为。我们不再需要一遍遍地编写相同的Repository实现，<strong>Spring Data能够让我们只编写Repository接口就可以了。根本就不再需要实现类了。</strong></p>
<p>例如，看一下下面的SpitterRepository接口。</p>
<p><img src="https://hexo-1300861231.cos.ap-shanghai.myqcloud.com/1584813088_20200322014419789_7469.png" alt></p>
<p>此时，SpitterRepository看上去并没有什么作用。但是，它的功能远超出了表面上所看到的那样。</p>
<p>编写Spring Data JPA Repository的关键在于要从一组接口中挑选一个进行扩展。这里，SpitterRepository扩展了Spring Data JPA的JpaRepository（稍后，我会介绍几个其他的接口）。通过这种方式，JpaRepository进行了参数化，所以它就能知道这是一个用来持久化Spitter对象的Repository，并且Spitter的ID类型为Long。另外，它还会继承18个执行持久化操作的通用方法，如保存Spitter、删除Spitter以及根据ID查询Spitter。</p>
<p>此时，你可能会想下一步就该编写一个类实现SpitterRepository和它的18个方法了。如果真的是这样的话，那本章就会变得乏味无聊了。其实，我们根本不需要编写SpitterRepository的任何实现类，相反，我们让Spring Data来为我们做这件事请。我们所需要做的就是对它提出要求。</p>
<p>为了要求Spring Data创建SpitterRepository的实现，我们需要在Spring配置中添加一个元素。如下的程序清单展现了<strong>在XML配置中启用Spring Data JPA所需要添加的内容</strong>：</p>
<p><img src="https://hexo-1300861231.cos.ap-shanghai.myqcloud.com/1584813087_20200322014419376_14389.png" alt></p>
<p><strong><code>&lt;jpa:repositories&gt;</code>元素</strong>掌握了Spring Data JPA的所有魔力。就像 <code>&lt;context:component-scan&gt;</code> 元素一样， <code>&lt;jpa:repositories&gt;</code> 元素也需要指定一个要进行扫描的base-package。不过， <code>&lt;context:component-scan&gt;</code> 会扫描包（及其子包）来查找带有@Component注解的类，而<code>&lt;jpa:repositories&gt;</code>会扫描它的基础包来查找扩展自Spring Data JPA Repository接口的所有接口。如果发现了扩展自Repository的接口，它会自动生成（在应用启动的时候）这个接口的实现。</p>
<p>如果要使用Java配置的话，那就不需要使用 <code>&lt;jpa:repositories&gt;</code> 元素了，而是要<strong>在Java配置类上添加@EnableJpaRepositories注解</strong>。如下就是一个Java配置类，它使用了@EnableJpaRepositories注解，并且会扫描com.habuma.spittr.db包：</p>
<p><img src="https://hexo-1300861231.cos.ap-shanghai.myqcloud.com/1584813087_20200322014419059_7019.png" alt></p>
<p>让我们回到SpitterRepository接口，它扩展自JpaRepository，而JpaRepository又扩展自Repository标记接口（虽然是间接的）。因此，SpitterRepository就传递性地扩展了Repository接口，也就是Repository扫描时所要查找的接口。当Spring Data找到它后，就会创建SpitterRepository的实现类，其中包含了继承自JpaRepository、PagingAndSortingRepository和CrudRepository的18个方法。</p>
<p>很重要的一点在于<strong>Repository的实现类是在应用启动的时候生成的，也就是Spring的应用上下文创建的时候。它并不是在构建时通过代码生成技术产生的，也不是接口方法调用时才创建的。</strong></p>
<p>很漂亮的技术，对吧？</p>
<h2 id="自定义查询方法">自定义查询方法</h2>
<p>Spring Data JPA很棒的一点在于它能为Spitter对象提供18个便利的方法来进行通用的JPA操作，而无需你编写任何持久化代码。但是，如果你的需求超过了它所提供的这18个方法的话，该怎么办呢？幸好，Spring Data JPA提供了几种方式来为Repository添加自定义的方法。让我们看一下如何为Spring Data JPA编写自定义的查询方法。</p>
<p>现在，SpitterRepository需要完成的一项功能是根据给定的username查找Spitter对象。比如，我们将SpitterRepository接口修改为如下所示的样子：</p>
<p><img src="https://hexo-1300861231.cos.ap-shanghai.myqcloud.com/1584813086_20200322014418548_27446.png" alt></p>
<p>这个新的findByUserName()非常简单，但是足以满足我们的需求。现在，该如何让Spring Data JPA提供这个方法的实现呢？</p>
<p>实际上，我们并不需要实现findByUsername()。方法签名已经告诉Spring Data JPA足够的信息来创建这个方法的实现了。</p>
<p>当创建Repository实现的时候，Spring Data会检查Repository接口的所有方法，解析方法的名称，并基于被持久化的对象来试图推测方法的目的。<strong>本质上，Spring Data定义了一组小型的领域特定语言（domain-specific language ，DSL），在这里，持久化的细节都是通过Repository方法的签名来描述的。</strong></p>
<p>Spring Data能够知道这个方法是要查找Spitter的，因为我们使用Spitter对JpaRepository进行了参数化。方法名findByUsername确定该方法需要根据username属性相匹配来查找Spitter，而username是作为参数传递到方法中来的。另外，因为在方法签名中定义了该方法要返回一个Spitter对象，而不是一个集合，因此它只会查找一个username属性匹配的Spitter。</p>
<p>findByUsername()方法非常简单，但是Spring Data也能处理更加有意思的方法名称。<strong>Repository方法是由一个动词、一个可选的主题（Subject）、关键词By以及一个断言所组成</strong>。在findByUsername()这个样例中，动词是<em>find</em>，断言是<em>Username</em>，主题并没有指定，暗含的主题是Spitter。</p>
<p>作为编写Repository方法名称的样例，我们参照名为readSpitterByFirstnameOrLastname()的方法，看一下方法中的各个部分是如何映射的。下图展现了这个方法是如何拆分的。</p>
<p>我们可以看到，这里的动词是<em>read</em>，与之前样例中的<em>find</em>有所差别。<strong>Spring Data允许在方法名中使用四种动词：get、read、find和count。其中，动词get、read和find是同义的，这三个动词对应的Repository方法都会查询数据并返回对象。而动词count则会返回匹配对象的数量，而不是对象本身。</strong></p>
<p><img src="https://hexo-1300861231.cos.ap-shanghai.myqcloud.com/1584813085_20200322014418238_28595.png" alt></p>
<p><strong>Repository方法的主题是可选的</strong>。它的主要目的是让你在命名方法的时候，有更多的灵活性。如果你更愿意将方法称为readSpittersByFirstnameOrLastname()而不是 readByFirstnameOrLastname()的话，那么你尽可以这么做。</p>
<p>对于大部分场景来说，主题会被省略掉。readSpittersByFirstnameOrLastname()与readPuppiesByFirstnameOrLastname()并没有什么差别，它们与readThose ThingsWeWantByFirstnameOrLastname()同样没有什么区别。<strong>要查询的对象类型是通过如何参数化JpaRepository接口来确定的，而不是方法名称中的主题。</strong></p>
<p>在省略主题的时候，有一种例外情况。如果<strong>主题的名称以Distinct开头</strong>的话，那么在生成查询的时候会确保所返回结果集中不包含重复记录。</p>
<p>断言是方法名称中最为有意思的部分，它指定了限制结果集的属性。在readByFirstnameOrLastname()这个样例中，会通过firstname属性或lastname属性的值来限制结果。</p>
<p><strong>在断言中，会有一个或多个限制结果的条件。每个条件必须引用一个属性，并且还可以指定一种比较操作。如果省略比较操作符的话，那么这暗指是一种相等比较操作</strong>。不过，我们也可以选择其他的比较操作，包括如下的种类：</p>
<ul>
<li>IsAfter、After、IsGreaterThan、GreaterThan</li>
<li>IsGreaterThanEqual、GreaterThanEqual</li>
<li>IsBefore、Before、IsLessThan、LessThan</li>
<li>IsLessThanEqual、LessThanEqual</li>
<li>IsBetween、Between</li>
<li>IsNull、Null</li>
<li>IsNotNull、NotNull</li>
<li>IsIn、In</li>
<li>IsNotIn、NotIn</li>
<li>IsStartingWith、StartingWith、StartsWith</li>
<li>IsEndingWith、EndingWith、EndsWith</li>
<li>IsContaining、Containing、Contains</li>
<li>IsLike、Like</li>
<li>IsNotLike、NotLike</li>
<li>IsTrue、True</li>
<li>IsFalse、False</li>
<li>Is、Equals</li>
<li>IsNot、Not</li>
</ul>
<p><strong>要对比的属性值就是方法的参数</strong>。完整的方法签名如下所示：</p>
<p><img src="https://hexo-1300861231.cos.ap-shanghai.myqcloud.com/1584813085_20200322014417927_3704.png" alt></p>
<p>要处理String类型的属性时，条件中可能还会包含<strong>IgnoringCase或IgnoresCase</strong>，这样在执行对比的时候就会不再考虑字符是大写还是小写。例如，要在firstname和lastname属性上忽略大小写，那么可以将方法签名改成如下的形式：</p>
<p><img src="https://hexo-1300861231.cos.ap-shanghai.myqcloud.com/1584813084_20200322014417616_19001.png" alt></p>
<p>需要注意，IgnoringCase和IgnoresCase是同义的，你可以随意挑选一个最合适的。</p>
<p>作为IgnoringCase/IgnoresCase的替代方案，我们还可以在所有条件的后面添加<strong>AllIgnoringCase或AllIgnoresCase</strong>，这样它就会忽略所有条件的大小写：</p>
<p><img src="https://hexo-1300861231.cos.ap-shanghai.myqcloud.com/1584813084_20200322014417404_10332.png" alt></p>
<p>注意，<strong>参数的名称是无关紧要的，但是它们的顺序必须要与方法名称中的操作符相匹配。</strong></p>
<p>最后，我们还可以在方法名称的结尾处添加<strong>OrderBy，实现结果集排序</strong>。例如，我们可以按照lastname属性升序排列结果集：</p>
<p><img src="https://hexo-1300861231.cos.ap-shanghai.myqcloud.com/1584813084_20200322014417095_14881.png" alt></p>
<p>如果要根据多个属性排序的话，只需将其依序添加到OrderBy中即可。例如，下面的样例中，首先会根据lastname升序排列，然后根据firstname属性降序排列：</p>
<p><img src="https://hexo-1300861231.cos.ap-shanghai.myqcloud.com/1584813083_20200322014416784_27716.png" alt></p>
<p>可以看到，<strong>条件部分是通过And或者Or进行分割的</strong>。</p>
<p>我们不可能（至少很难）提供一个权威的列表，将使用Spring Data方法命名约定可以编写出来的方法种类全部列出来。但是，如下给出了几个符合方法命名约定的方法签名：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">List&lt;Pet&gt; <span class="title">findPetsByBreedIn</span><span class="params">(List&lt;String&gt; breed)</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">countProductsByDiscontinuedTrue</span><span class="params">()</span></span></span><br><span class="line"><span class="function">List&lt;Order&gt; <span class="title">findByShippingDateBetween</span><span class="params">(Date start, Date end)</span></span></span><br></pre></td></tr></table></figure>
<p>我们只是初步体验了所能声明的方法种类，Spring Data JPA会为我们实现这些方法。现在，我们只需知道<strong>通过使用属性名和关键字构建Repository方法签名，就能让Spring Data JPA生成方法实现</strong>，完成几乎所有能够想象到的查询。</p>
<p>不过，Spring Data这个小型的DSL依旧有其局限性，有时候通过方法名称表达预期的查询很烦琐，甚至无法实现。如果遇到这种情形的话，Spring Data能够让我们通过@Query注解来解决问题。</p>
<h2 id="声明自定义查询语句">声明自定义查询语句</h2>
<p>假设我们想要创建一个Repository方法，用来查找E-mail地址是Gmail邮箱的Spitter。有一种方式就是定义一个findByEmailLike()方法，然后每次想查找Gmail用户的时候就将<code>%gmail.com</code>传递进来。不过，更好的方案是定义一个更加便利的findAllGmailSpitters()方法，这样的话，就不用将Email地址的一部分传递进来了：</p>
<p><img src="https://hexo-1300861231.cos.ap-shanghai.myqcloud.com/1584813083_20200322014416474_20056.png" alt></p>
<p>不过，这个方法并不符合Spring Data的方法命名约定。当Spring Data试图生成这个方法的实现时，无法将方法名的内容与Spitter元模型进行匹配，因此会抛出异常。</p>
<p>如果所需的数据无法通过方法名称进行恰当地描述，那么我们可以使用@Query注解，为Spring Data提供要执行的查询。对于findAllGmailSpitters()方法，我们可以按照如下的方式来使用@Query注解：</p>
<p><img src="https://hexo-1300861231.cos.ap-shanghai.myqcloud.com/1584813082_20200322014416062_28879.png" alt></p>
<p>我们依然不需要编写findAllGmailSpitters()方法的实现，只需提供查询即可，让Spring Data JPA知道如何实现这个方法。</p>
<p>可以看到，当使用方法命名约定很难表达预期的查询时，@Query注解能够发挥作用。如果按照命名约定，方法的名称特别长的时候，也可以使用这个注解。例如，考虑如下的查询方法：</p>
<p><img src="https://hexo-1300861231.cos.ap-shanghai.myqcloud.com/1584813081_20200322014415752_14374.png" alt></p>
<p>这真的是一个方法的名称！我不得不在返回类型后将其断开，这样才能适应本书页面的宽度。</p>
<p>我承认这是一个有点牵强的例子。但在现实世界中，确实存在这样的需求，使用Repository方法所执行的查询会得到一个很长的方法名。在这种情况下，你最好使用一个较短的方法名，并使用@Query来指定该方法要如何查询数据库。</p>
<p>对于Spring Data JPA的接口来说，@Query是一种添加自定义查询的便利方式。但是，它仅限于单个JPA查询。如果我们需要更为复杂的功能，无法在一个简单的查询中处理的话，该怎么办呢？</p>
<h2 id="混合自动化实现和手动定义的方法">混合自动化实现和手动定义的方法</h2>
<p>有些时候，我们需要Repository所提供的功能是无法用Spring Data的方法命名约定来描述的，甚至无法用@Query注解设置查询来实现。尽管Spring Data JPA非常棒，但是它依然有其局限性，可能需要我们按照传统的方式来编写Repository方法：也就是直接使用EntityManager。当遇到这种情况的时候，我们是不是要放弃Spring Data JPA，重新按照手动实现接口方式来编写Repository呢？</p>
<p>简单来说，是这样的。如果你需要做的事情无法通过Spring Data JPA来实现，那就必须要在一个比Spring Data JPA更低的层级上使用JPA。好消息是我们没有必要完全放弃Spring Data JPA。我们只需在必须使用较低层级JPA的方法上，才使用这种传统的方式即可，而对于Spring Data JPA知道该如何处理的功能，我们依然可以通过它来实现。</p>
<p><strong>当Spring Data JPA为Repository接口生成实现的时候，它还会查找名字与接口相同，并且添加了Impl后缀的一个类。如果这个类存在的话，Spring Data JPA将会把它的方法与Spring Data JPA所生成的方法合并在一起</strong>。对于SpitterRepository接口而言，要查找的类名为SpitterRepositoryImpl。</p>
<p>为了阐述该功能，假设我们需要在SpitterRepository中添加一个方法，发表Spittle数量在10,000及以上的Spitter将会更新为Elite状态。使用Spring Data JPA的方法命名约定或使用@Query均没有办法声明这样的方法。最为可行的方案是使用如下的eliteSweep()方法。</p>
<p><img src="https://hexo-1300861231.cos.ap-shanghai.myqcloud.com/1584813080_20200322014415543_3938.jpg" alt></p>
<p>我们可以看到，eliteSweep()方法与之前手动创建的Repository方法并没有太大的差别。SpitterRepositoryImpl没有什么特殊之处，它使用被注入的EntityManager来完成预期的任务。</p>
<p><strong>注意，SpitterRepositoryImpl并没有实现SpitterRepository接口。Spring Data JPA负责实现这个接口</strong>。SpitterRepositoryImpl（将它与Spring Data的Repository关联起来的是它的名字）实现了SpitterSweeper接口，它如下所示：</p>
<p><img src="https://hexo-1300861231.cos.ap-shanghai.myqcloud.com/1584813080_20200322014415129_24477.png" alt></p>
<p><strong>我们还需要确保eliteSweep()方法会被声明在SpitterRepository接口中。要实现这一点，避免代码重复的简单方式就是修改SpitterRepository，让它扩展SpitterSweeper</strong>：</p>
<p><img src="https://hexo-1300861231.cos.ap-shanghai.myqcloud.com/1584813080_20200322014414820_10739.png" alt></p>
<p>如前所述，Spring Data JPA将实现类与接口关联起来是基于接口的名称。但是，Impl后缀只是默认的做法，如果你想使用其他后缀的话，只需在配置@EnableJpa-Repositories的时候，设置<strong>repositoryImplementationPostfix属性</strong>即可：</p>
<p><img src="https://hexo-1300861231.cos.ap-shanghai.myqcloud.com/1584813079_20200322014414609_12885.png" alt></p>
<p>如果在XML中使用 <code>&lt;jpa:repositories&gt;</code> 元素来配置Spring Data JPA的话，我们可以借助repository-impl-postfix属性指定后缀：</p>
<p><img src="https://hexo-1300861231.cos.ap-shanghai.myqcloud.com/1584813078_20200322014414393_1910.png" alt></p>
<p>我们将后缀设置成了Helper，Spring Data JPA将会查找名为SpitterRepository-Helper的类，用它来匹配SpitterRepository接口。</p>

      </div>
      
      
      
    </div>
    
  <ul class="breadcrumb">
          
            <li><a href="/quotes/">QUOTES</a></li>
            <li><a href="/quotes/Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">SPRING学习笔记</a></li>
            <li>44-SPRINGORM</li>
          
  </ul>

    
    
    
  </div>


          </div>
          

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#null"><span class="nav-text">Spring集成Hibernate</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#声明Hibernate的Session工厂"><span class="nav-text">声明Hibernate的Session工厂</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#自动注入SessionFactory实现非耦合的Hibernate编程"><span class="nav-text">自动注入SessionFactory实现非耦合的Hibernate编程</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#null"><span class="nav-text">Spring集成JPA</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#EntityManagerFactory配置及注入"><span class="nav-text">EntityManagerFactory配置及注入</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#配置应用程序管理类型的EntityManagerFactory"><span class="nav-text">配置应用程序管理类型的EntityManagerFactory</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#配置容器管理类型的EntityManagerFactory"><span class="nav-text">配置容器管理类型的EntityManagerFactory</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#从JNDI获取EntityManagerFactory"><span class="nav-text">从JNDI获取EntityManagerFactory</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#自动注入EntityManagerFactory实现非耦合的JPA编程"><span class="nav-text">自动注入EntityManagerFactory实现非耦合的JPA编程</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#null"><span class="nav-text">自动化的JPARepository实现</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#自动生成JPARepository接口实现"><span class="nav-text">自动生成JPARepository接口实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#自定义查询方法"><span class="nav-text">自定义查询方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#声明自定义查询语句"><span class="nav-text">声明自定义查询语句</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#混合自动化实现和手动定义的方法"><span class="nav-text">混合自动化实现和手动定义的方法</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <img class="site-author-image" itemprop="image" alt="jiateng.jiang"
    src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">jiateng.jiang</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">44</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">32</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">jiateng.jiang</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v4.0.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.4.2
  </div>

        












        
      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/pisces.js"></script>
<script src="/js/next-boot.js"></script>



  






  <script src="/js/local-search.js"></script>








<script>
if (document.querySelectorAll('div.pdf').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/pdfobject@2/pdfobject.min.js', () => {
    document.querySelectorAll('div.pdf').forEach(element => {
      PDFObject.embed(element.getAttribute('target'), element, {
        pdfOpenParams: {
          navpanes: 0,
          toolbar: 0,
          statusbar: 0,
          pagemode: 'thumbs',
          view: 'FitH'
        },
        PDFJS_URL: '/lib/pdf/web/viewer.html',
        height: element.getAttribute('height') || '100%'
      });
    });
  }, window.PDFObject);
}
</script>





  

  

  

</body>
</html>
