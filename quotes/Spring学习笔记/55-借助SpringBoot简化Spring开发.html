<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '7.4.2',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: true,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"manual","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.json',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    },
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="在我刚开始学习微积分课程的时候，我们学习了函数的导数。当时我们使用非常复杂的极限来计算函数的导数。即便函数非常简单，计算导数相关的工作依然像噩梦一样。在布置完作业、建立完学习小组并考完试后，班上的大多数同学都能够完成这项任务了。但是它的单调无趣依然让我们无法忍受。如果“微积分（上）”的课程就这样的话，那在“微积分（下）”中，又该有怎样恐怖的数学计算在等着我们呢？">
<meta property="og:type" content="website">
<meta property="og:title" content="JJT-个人Wiki">
<meta property="og:url" content="https:&#x2F;&#x2F;hexo-pages-1300861231.cos-website.ap-shanghai.myqcloud.com&#x2F;quotes&#x2F;Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0&#x2F;55-%E5%80%9F%E5%8A%A9SpringBoot%E7%AE%80%E5%8C%96Spring%E5%BC%80%E5%8F%91.html">
<meta property="og:site_name" content="JJT-个人Wiki">
<meta property="og:description" content="在我刚开始学习微积分课程的时候，我们学习了函数的导数。当时我们使用非常复杂的极限来计算函数的导数。即便函数非常简单，计算导数相关的工作依然像噩梦一样。在布置完作业、建立完学习小组并考完试后，班上的大多数同学都能够完成这项任务了。但是它的单调无趣依然让我们无法忍受。如果“微积分（上）”的课程就这样的话，那在“微积分（下）”中，又该有怎样恐怖的数学计算在等着我们呢？">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https:&#x2F;&#x2F;hexo-1300861231.cos.ap-shanghai.myqcloud.com&#x2F;1584862925_20200322153655825_21924.png">
<meta property="og:image" content="https:&#x2F;&#x2F;hexo-1300861231.cos.ap-shanghai.myqcloud.com&#x2F;1584862925_20200322153655608_1395.png">
<meta property="og:image" content="https:&#x2F;&#x2F;hexo-1300861231.cos.ap-shanghai.myqcloud.com&#x2F;1584862925_20200322153655388_22297.png">
<meta property="og:image" content="https:&#x2F;&#x2F;hexo-1300861231.cos.ap-shanghai.myqcloud.com&#x2F;1584862925_20200322153655174_1247.png">
<meta property="og:image" content="https:&#x2F;&#x2F;hexo-1300861231.cos.ap-shanghai.myqcloud.com&#x2F;1584862924_20200322153654958_5611.png">
<meta property="og:image" content="https:&#x2F;&#x2F;hexo-1300861231.cos.ap-shanghai.myqcloud.com&#x2F;1584862924_20200322153654745_21905.jpg">
<meta property="og:image" content="https:&#x2F;&#x2F;hexo-1300861231.cos.ap-shanghai.myqcloud.com&#x2F;1584862924_20200322153654523_31827.jpg">
<meta property="og:image" content="https:&#x2F;&#x2F;hexo-1300861231.cos.ap-shanghai.myqcloud.com&#x2F;1584862924_20200322153654197_20734.png">
<meta property="og:image" content="https:&#x2F;&#x2F;hexo-1300861231.cos.ap-shanghai.myqcloud.com&#x2F;1584862924_20200322153653975_15227.png">
<meta property="og:image" content="https:&#x2F;&#x2F;hexo-1300861231.cos.ap-shanghai.myqcloud.com&#x2F;1584862923_20200322153653762_8382.png">
<meta property="og:image" content="https:&#x2F;&#x2F;hexo-1300861231.cos.ap-shanghai.myqcloud.com&#x2F;1584862923_20200322153653548_25937.jpg">
<meta property="og:image" content="https:&#x2F;&#x2F;hexo-1300861231.cos.ap-shanghai.myqcloud.com&#x2F;1584862923_20200322153653222_7947.jpg">
<meta property="og:image" content="https:&#x2F;&#x2F;hexo-1300861231.cos.ap-shanghai.myqcloud.com&#x2F;1584862923_20200322153652888_11563.png">
<meta property="og:image" content="https:&#x2F;&#x2F;hexo-1300861231.cos.ap-shanghai.myqcloud.com&#x2F;1584862922_20200322153652675_10260.png">
<meta property="og:image" content="https:&#x2F;&#x2F;hexo-1300861231.cos.ap-shanghai.myqcloud.com&#x2F;1584862922_20200322153652459_13179.jpg">
<meta property="og:image" content="https:&#x2F;&#x2F;hexo-1300861231.cos.ap-shanghai.myqcloud.com&#x2F;1584862922_20200322153652132_15023.png">
<meta property="og:image" content="https:&#x2F;&#x2F;hexo-1300861231.cos.ap-shanghai.myqcloud.com&#x2F;1584862922_20200322153651917_26144.png">
<meta property="og:image" content="https:&#x2F;&#x2F;hexo-1300861231.cos.ap-shanghai.myqcloud.com&#x2F;1584862921_20200322153651701_883.jpg">
<meta property="og:image" content="https:&#x2F;&#x2F;hexo-1300861231.cos.ap-shanghai.myqcloud.com&#x2F;1584862921_20200322153651271_1573.png">
<meta property="og:image" content="https:&#x2F;&#x2F;hexo-1300861231.cos.ap-shanghai.myqcloud.com&#x2F;1584862921_20200322153650957_25423.jpg">
<meta property="og:image" content="https:&#x2F;&#x2F;hexo-1300861231.cos.ap-shanghai.myqcloud.com&#x2F;1584862921_20200322153650738_7390.png">
<meta property="og:image" content="https:&#x2F;&#x2F;hexo-1300861231.cos.ap-shanghai.myqcloud.com&#x2F;1584862921_20200322153650526_17156.png">
<meta property="og:image" content="https:&#x2F;&#x2F;hexo-1300861231.cos.ap-shanghai.myqcloud.com&#x2F;1584862920_20200322153650314_26057.png">
<meta property="og:image" content="https:&#x2F;&#x2F;hexo-1300861231.cos.ap-shanghai.myqcloud.com&#x2F;1584862920_20200322153650101_7990.png">
<meta property="og:image" content="https:&#x2F;&#x2F;hexo-1300861231.cos.ap-shanghai.myqcloud.com&#x2F;1584862920_20200322153649373_16287.png">
<meta property="og:image" content="https:&#x2F;&#x2F;hexo-1300861231.cos.ap-shanghai.myqcloud.com&#x2F;1584862920_20200322153649161_15608.png">
<meta property="og:image" content="https:&#x2F;&#x2F;hexo-1300861231.cos.ap-shanghai.myqcloud.com&#x2F;1584862919_20200322153648949_26231.png">
<meta property="og:image" content="https:&#x2F;&#x2F;hexo-1300861231.cos.ap-shanghai.myqcloud.com&#x2F;1584862919_20200322153648737_29938.png">
<meta property="og:image" content="https:&#x2F;&#x2F;hexo-1300861231.cos.ap-shanghai.myqcloud.com&#x2F;1584862919_20200322153648519_23016.png">
<meta property="og:image" content="https:&#x2F;&#x2F;hexo-1300861231.cos.ap-shanghai.myqcloud.com&#x2F;1584862919_20200322153648305_2965.jpg">
<meta property="og:image" content="https:&#x2F;&#x2F;hexo-1300861231.cos.ap-shanghai.myqcloud.com&#x2F;1584862919_20200322153648086_13708.png">
<meta property="og:image" content="https:&#x2F;&#x2F;hexo-1300861231.cos.ap-shanghai.myqcloud.com&#x2F;1584862918_20200322153647873_12030.jpg">
<meta property="og:image" content="https:&#x2F;&#x2F;hexo-1300861231.cos.ap-shanghai.myqcloud.com&#x2F;1584862918_20200322153647550_14169.png">
<meta property="og:image" content="https:&#x2F;&#x2F;hexo-1300861231.cos.ap-shanghai.myqcloud.com&#x2F;1584862918_20200322153647338_32627.png">
<meta property="og:image" content="https:&#x2F;&#x2F;hexo-1300861231.cos.ap-shanghai.myqcloud.com&#x2F;1584862918_20200322153647127_1698.png">
<meta property="og:image" content="https:&#x2F;&#x2F;hexo-1300861231.cos.ap-shanghai.myqcloud.com&#x2F;1584862917_20200322153646916_3489.png">
<meta property="og:image" content="https:&#x2F;&#x2F;hexo-1300861231.cos.ap-shanghai.myqcloud.com&#x2F;1584862917_20200322153646704_22467.png">
<meta property="og:image" content="https:&#x2F;&#x2F;hexo-1300861231.cos.ap-shanghai.myqcloud.com&#x2F;1584862917_20200322153646493_2562.png">
<meta property="og:image" content="https:&#x2F;&#x2F;hexo-1300861231.cos.ap-shanghai.myqcloud.com&#x2F;1584862917_20200322153646282_5063.png">
<meta property="og:image" content="https:&#x2F;&#x2F;hexo-1300861231.cos.ap-shanghai.myqcloud.com&#x2F;1584862917_20200322153646071_2837.png">
<meta property="og:image" content="https:&#x2F;&#x2F;hexo-1300861231.cos.ap-shanghai.myqcloud.com&#x2F;1584862916_20200322153645859_2175.png">
<meta property="og:image" content="https:&#x2F;&#x2F;hexo-1300861231.cos.ap-shanghai.myqcloud.com&#x2F;1584862916_20200322153645647_25679.png">
<meta property="og:image" content="https:&#x2F;&#x2F;hexo-1300861231.cos.ap-shanghai.myqcloud.com&#x2F;1584862916_20200322153645390_9457.jpg">
<meta property="og:updated_time" content="2020-12-15T11:07:33.044Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https:&#x2F;&#x2F;hexo-1300861231.cos.ap-shanghai.myqcloud.com&#x2F;1584862925_20200322153655825_21924.png">

<link rel="canonical" href="https://hexo-pages-1300861231.cos-website.ap-shanghai.myqcloud.com/quotes/Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/55-%E5%80%9F%E5%8A%A9SpringBoot%E7%AE%80%E5%8C%96Spring%E5%BC%80%E5%8F%91">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: false,
    isPage: true,
    isArchive: false
  };
</script>

  <title> | JJT-个人Wiki
  </title>
  








  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">JJT-个人Wiki</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">you see see you one day day</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="搜索..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
  
  

          <div class="content">
            

  <div class="posts-expand">
    
    
    
    <div class="post-block" lang="zh-CN">
      <header class="post-header">

<h1 class="post-title" itemprop="name headline">
</h1>

<div class="post-meta">
  
  <ul class="breadcrumb">
          
            <li><a href="/quotes/">QUOTES</a></li>
            <li><a href="/quotes/Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">SPRING学习笔记</a></li>
            <li>55-借助SPRINGBOOT简化SPRING开发</li>
          
  </ul>

</div>

</header>

      
      
      
      <div class="post-body">
          <p>在我刚开始学习微积分课程的时候，我们学习了函数的导数。当时我们使用非常复杂的极限来计算函数的导数。即便函数非常简单，计算导数相关的工作依然像噩梦一样。</p><p>在布置完作业、建立完学习小组并考完试后，班上的大多数同学都能够完成这项任务了。但是它的单调无趣依然让我们无法忍受。如果“微积分（上）”的课程就这样的话，那在“微积分（下）”中，又该有怎样恐怖的数学计算在等着我们呢？</p><a id="more"></a>

<p>然后，老师给我们开了一个玩笑。通过使用一个简单的公式就能快速将导数计算出来（如果你学习过微积分的话，你应该能够明白我说的是什么）。通过这种新技巧，在以前计算一个函数导数的时间内，我们能够计算出十多个函数的导数。</p>
<p>此时，一位同学向老师提出了一个问题，这也是我们每位同学所想的：“您为什么不在第一天就教会我们这个公式呢？！”</p>
<p>老师这样解释，比较困难的那种方法能够帮助我们理解导数的含义、告诉我们它的特性，并说这种方式对我们有这样那样的好处。</p>
<p>现在，我们用整本书的篇幅介绍了Spring，我发现自己处在类似于微积分老师那样的位置。尽管Spring带来的主要益处就是简化Java开发，但本章将会介绍Spring Boot如何让这项任务变得更加简单。从Spring创建以来，Spring Boot大概是Spring领域中最令人兴奋的事情了。 <strong>Spring Boot在Spring之上，构建了全新的开发模型，移除了开发Spring应用中很多单调乏味的内容。</strong></p>
<p>我们首先整体上了解一下Spring Boot，看它是如何简化Spring的。在本章结束之前，我们将会使用Spring Boot构建一个完整的（尽管比较简单）应用程序。</p>
<h1>Spring Boot简介</h1>
<p><strong>Spring Boot的四个主要特性：Spring Boot Starter、自动配置、命令行接口、Actuator。</strong></p>
<p>在Spring家族中，Spring Boot是令人兴奋（也许我敢说它是改变游戏规则的）的新项目。它提供了四个主要的特性，能够改变开发Spring应用程序的方式：</p>
<ul>
<li>Spring Boot Starter：它将常用的依赖分组进行了整合，将其合并到一个依赖中，这样就可以一次性添加到项目的Maven或Gradle构建中；</li>
<li>自动配置：Spring Boot的自动配置特性利用了Spring 4对条件化配置的支持，合理地推测应用所需的bean并自动化配置它们；</li>
<li>命令行接口（<em>Command-line interface，CLI</em>）：Spring Boot的CLI发挥了Groovy编程语言的优势，并结合自动配置进一步简化Spring应用的开发；</li>
<li>Actuator：它为Spring Boot应用添加了一定的管理特性。</li>
</ul>
<p>在本章中，我们将会使用Spring Boot的所有特性构建一个小型的应用程序。但首先，我们快速了解一下每项特性，更好地体验它们如何简化Spring编程模型。</p>
<h2 id="添加Starter依赖">添加Starter依赖</h2>
<p>有两种烤制蛋糕的方式，有热情的人会将面粉、鸡蛋、糖、发酵粉、盐、奶油、香草调料以及牛奶混合在一起，和成糊状。或者也可以购买预先打包好的蛋糕，它包含了所需的大部分原料，我们只需添加一些含水分的材料即可，如水、鸡蛋和植物油。</p>
<p>预先打包好的蛋糕将制作蛋糕过程中所需的各种材料集合在了一起，作为一项材料来使用，与之类似， <strong>Spring Boot Starter将应用所需的各种依赖聚合成一项依赖。</strong></p>
<p>为了阐述该功能，假设我们要从头开始编写一个新的Spring应用。这是一个Web项目，所以需要使用Spring MVC。同时，还要有REST API将资源暴露为JSON，所以在构建中需要包含Jackson JSON库。</p>
<p>因为应用需要使用JDBC从关系型数据库中存储和查询数据，因此我们希望确保包含了Spring的JDBC模块（为了使用JdbcTemplate）和Spring的事务模块（为了使用声明式事务的支持）。对于数据库本身，H2数据库是个不错的选择。</p>
<p>对了，我们还需要使用Thymeleaf来建立Spring MVC视图。</p>
<p>如果使用Gradle构建项目的话，在build.gradle中（至少）需要包含如下的依赖：</p>
<p><img src="https://hexo-1300861231.cos.ap-shanghai.myqcloud.com/1584862925_20200322153655825_21924.png" alt></p>
<p>幸好，Gradle能够非常简洁地表达依赖。（为简单起见，我不再展现这个依赖列表在Maven的pom.xml文件是什么样子了。）。即便如此，创建这个文件还是牵扯到许多的事情，而对它的维护则会更加麻烦。这些依赖之间是如何协作的呢？当应用程序不断地成长和演进，依赖管理将会变得更加具有挑战性。</p>
<p>但是，如果我们使用Spring Boot Starer所提供的预打包依赖的话，那么Gradle依赖列表能够更加简短一些：</p>
<p><img src="https://hexo-1300861231.cos.ap-shanghai.myqcloud.com/1584862925_20200322153655608_1395.png" alt></p>
<p>可以看到，Spring Boot的Web和JDBC Starter取代了几个更加细粒度的依赖。我们依然还需要包含H2和Thymeleaf的依赖，不过其他的依赖都已经放到了Starter中。除了依赖列表更加简短，我们可以相信由Starter所提供的依赖版本能够互相兼容。</p>
<p><strong>Spring Boot提供了多个Starter，Web和JDBC只是其中的两个。下表列出了我在编写本章时，所有可用的Starter。</strong></p>
<table>
<thead>
<tr>
<th>Starter</th>
<th>所提供的依赖</th>
</tr>
</thead>
<tbody>
<tr>
<td>spring-boot-starter-actuator</td>
<td>spring-boot-starter 、spring-boot-actuator 、spring-core</td>
</tr>
<tr>
<td>spring-boot-starter-amqp</td>
<td>spring-boot-starter 、spring-boot-rabbit 、spring-core 、 spring-tx</td>
</tr>
<tr>
<td>spring-boot-starter-aop</td>
<td>spring-boot-starter 、spring-aop 、AspectJ Runtime 、AspectJ Weaver 、spring-core</td>
</tr>
<tr>
<td>spring-boot-starter-batch</td>
<td>spring-boot-starter 、HSQLDB 、spring-jdbc 、spring-batch-core 、spring-core</td>
</tr>
<tr>
<td>spring-boot-starter-elasticsearch</td>
<td>spring-boot-starter、 spring-data-elasticsearch、 spring-core、 spring-tx</td>
</tr>
<tr>
<td>spring-boot-starter-gemfire</td>
<td>spring-boot-starter、 Gemfire、 spring-core、 spring-tx、 spring-context、 spring-context-support、 spring-data-gemfire</td>
</tr>
<tr>
<td>spring-boot-starter-data-jpa</td>
<td>spring-boot-starter、 spring-boot-starter-jdbc、 spring-boot-starter-aop、 spring-core、 Hibernate EntityManager、 spring-orm、 spring-data-jpa、 spring-aspects</td>
</tr>
<tr>
<td>spring-boot-starter-data-mongodb</td>
<td>spring-boot-starter、 MongoDB Java 驱动 、 spring-core、 spring-tx、 spring-data-mongodb</td>
</tr>
<tr>
<td>spring-boot-starter-data-rest</td>
<td>spring-boot-starter、 spring-boot-starter-web、 Jackson 注解 、 Jackson 数据绑定 、 spring-core、 spring-tx、 spring-data-rest-webmvc</td>
</tr>
<tr>
<td>spring-boot-starter-data-solr</td>
<td>spring-boot-starter、 Solrj、 spring-core、 spring-tx、 spring-data-solr、 Apache HTTP Mime</td>
</tr>
<tr>
<td>spring-boot-starter-freemarker</td>
<td>spring-boot-starter、 spring-boot-starter-web、 Freemarker、 spring-core、 spring-context-support</td>
</tr>
<tr>
<td>spring-boot-starter-groovy-templ-ates</td>
<td>spring-boot-starter、 spring-boot-starter-web、 Groovy、 Groovy 模板、spring-core</td>
</tr>
<tr>
<td>spring-boot-starter-hornetq</td>
<td>spring-boot-starter、 spring-core、 spring-jms、 Hornet JMS Client</td>
</tr>
<tr>
<td>spring-boot-starter-integration</td>
<td>spring-boot-starter、 spring-aop、 spring-tx、 spring-web、 spring-webmvc、 spring-integration-core、 spring-integration-file、 spring-integration-http、 spring-integration-ip、 spring-integration-stream</td>
</tr>
<tr>
<td>spring-boot-starter-jdbc</td>
<td>spring-boot-starter、 spring-jdbc 、tomcat-jdbc、 spring-tx</td>
</tr>
<tr>
<td>spring-boot-starter-jetty</td>
<td>jetty-webapp、 jetty-jsp</td>
</tr>
<tr>
<td>spring-boot-starter-log4j</td>
<td>jcl-over-slf4j、 jul-to-slf4j 、slf4j-log4j12、log4j</td>
</tr>
<tr>
<td>spring-boot-starter -logging</td>
<td>jcl-over-slf4j、 jul-to-slf4j 、log4j-over-slf4j、 logback-classic</td>
</tr>
<tr>
<td>spring-boot-starter-mobile</td>
<td>spring-boot-starter、 spring-boot-starter-web、 spring-mobile-device</td>
</tr>
<tr>
<td>spring-boot-starter-redis</td>
<td>spring-boot-starter、 spring-data-redis、 lettuce</td>
</tr>
<tr>
<td>spring-boot-starter-remote-shell</td>
<td>spring-boot-starter-actuator、 spring-context、 org.crashub.**</td>
</tr>
<tr>
<td>spring-boot-starter-security</td>
<td>spring-boot-starter、 spring-security-config、 spring-security-web、 spring-aop、 spring-beans、 spring-context、 spring-core、 spring-expression、 spring-web</td>
</tr>
<tr>
<td>spring-boot-starter-social-facebook</td>
<td>spring-boot-starter、 spring-boot-starter-web、 spring-core、 spring-social-config、 spring-social-core、 spring-social-web、 spring-social-facebook</td>
</tr>
<tr>
<td>spring-boot-starter-social-twitter</td>
<td>spring-boot-starter、 spring-boot-starter-web、 spring-core、 spring-social-config、 spring-social-core、 spring-social-web、 spring-social-twitter</td>
</tr>
<tr>
<td>spring-boot-starter-social-linkedin</td>
<td>spring-boot-starter、 spring-boot-starter-web、 spring-core、 spring-social-config、 spring-social-core、 spring-social-web、 spring-social-linkedin</td>
</tr>
<tr>
<td>spring-boot-starter</td>
<td>spring-boot、 spring-boot-autoconfigure、 spring-boot-starter-logging</td>
</tr>
<tr>
<td>spring-boot-starter-test</td>
<td>spring-boot-starter-logging、 spring-boot、 junit、mockito-core、 hamcrest-library、 spring-test</td>
</tr>
<tr>
<td>spring-boot-starter-thymeleaf</td>
<td>spring-boot-starter、 spring-boot-starter-web、 spring-core、 thymeleaf-spring4、 thymeleaf-layout-dialect</td>
</tr>
<tr>
<td>spring-boot-starter-tomcat</td>
<td>tomcat-embed-core、 tomcat-embed-logging-juli</td>
</tr>
<tr>
<td>spring-boot-starter-web</td>
<td>spring-boot-starter、 spring-boot-starter-tomcat、 jackson-databind、 spring-web、 spring-webmvc</td>
</tr>
<tr>
<td>spring-boot-starter-websocket</td>
<td>spring-boot-starter-web、 spring-websocket、 tomcat-embed-core、 tomcat-embed-logging-juli</td>
</tr>
<tr>
<td>spring-boot-starter-ws</td>
<td>spring-boot-starter、 spring-boot-starter-web、 spring-core、 spring-jms、 spring-oxm、 spring-ws-core、 spring-ws-support</td>
</tr>
</tbody>
</table>
<p>如果查看这些Starter依赖的内部原理，你会发现 <strong>Starter的工作方式也没有什么神秘之处。它使用了Maven和Gradle的依赖传递方案。</strong> Starter在自己的pom.xml文件中声明了多个依赖。当我们将某一个Starter依赖添加到Maven或Gradle构建中的时候，Starter的依赖将会自动地传递性解析。这些依赖本身可能也会有其他的依赖。一个Starter可能会传递性地引入几十个依赖。</p>
<p>需要注意，很多Starter引用了其他的Starter。例如，mobile Starter就引用了Web Starter，而后者又引用了Tomcat Starter。 <strong>大多数的Starter都会引用spring-boot-starter，它实际上是一个基础的Starter（当然，它也依赖了logging Starter）。</strong> 依赖是传递性的，将mobile Starter添加为依赖之后，就相当于添加了它下面的所有Starter。</p>
<h2 id="自动配置">自动配置</h2>
<p><strong>Spring Boot的Starter减少了构建中依赖列表的长度，而Spring Boot的自动配置功能则削减了Spring配置的数量。它在实现时，会考虑应用中的其他因素并推断你所需要的Spring配置。</strong></p>
<p>作为样例，让我们重新回忆第6章（程序清单6.4），要将Thymeleaf模板作为Spring MVC的视图，至少需要三个bean：ThymeleafViewResolver、SpringTemplateEngine和TemplateResolver。但是， <strong>使用Spring Boot自动配置Thymeleaf视图模板，我们需要做的仅仅是将Thymeleaf添加到项目的类路径中。如果Spring Boot探测到Thymeleaf位于类路径中，它就会推断我们需要使用Thymeleaf实现Spring MVC的视图功能，并自动配置这些bean。</strong></p>
<p>Spring Boot Starter也会触发自动配置。例如，在Spring Boot应用中，如果我们想要使用Spring MVC的话，所需要做的仅仅是将Web Starter作为依赖放到构建之中。将Web Starter作为依赖放到构建中以后，它会自动添加Spring MVC依赖。 <strong>如果Spring Boot的Web自动配置探测到Spring MVC位于类路径下，它将会自动配置支持Spring MVC的多个bean，包括视图解析器、资源处理器以及消息转换器（等等）。</strong> 我们接下来需要做的就是编写处理请求的控制器。</p>
<h2 id="Spring-Boot-CLI">Spring Boot CLI</h2>
<p><strong>Spring Boot CLI充分利用了Spring Boot Starter和自动配置的魔力，并添加了一些Groovy的功能。</strong> 它简化了Spring的开发流程，通过CLI，我们能够运行一个或多个Groovy脚本，并查看它是如何运行的。 <strong>在应用的运行过程中，CLI能够自动导入Spring类型并解析依赖。</strong></p>
<p>用来阐述Spring Boot CLI的最有趣的例子就是如下的Groovy脚本：</p>
<p><img src="https://hexo-1300861231.cos.ap-shanghai.myqcloud.com/1584862925_20200322153655388_22297.png" alt></p>
<p>不管你是否相信，这是一个完整的（尽管比较简单）Spring应用，它可以在Spring Boot CLI中运行。包括空格，它的长度只有82个字符。你可以将其粘贴到Twitter客户端，并分享给你的朋友们。</p>
<p>去掉不必要的空格，我们能够得到只有64个字符的一行代码：</p>
<p><img src="https://hexo-1300861231.cos.ap-shanghai.myqcloud.com/1584862925_20200322153655174_1247.png" alt></p>
<p>这个版本更加简单，在一条Twitter的推文中，我们可以粘贴两次。但它依然是一个完整可运行的（尽管特性比较简陋）Spring应用。</p>
<p><strong>Spring Boot CLI中使用spring run Hi.groovy运行Spring应用。</strong> 如果你已经安装过Spring Boot CLI，我们可以使用如下的命令行来运行它：</p>
<p><img src="https://hexo-1300861231.cos.ap-shanghai.myqcloud.com/1584862924_20200322153654958_5611.png" alt></p>
<p>以推文的形式来展示Spring Boot CLI的功能是很有意思的，但是它所能做的事情并不仅限于我们所看到的这些。在后面小节中，我们将会看到如何使用Groovy和CLI构建更加完整的应用。</p>
<h2 id="Actuator">Actuator</h2>
<p>Spring Boot Actuator为Spring Boot项目带来了很多有用的特性，包括：</p>
<ul>
<li>管理端点；</li>
<li>合理的异常处理以及默认的“/error”映射端点；</li>
<li>获取应用信息的“/info”端点；</li>
<li>当启用Spring Security时，会有一个审计事件框架。</li>
</ul>
<p>这些特性都是很有用的，但Actuator最有用和最有意思的特性是管理端点。在后面小节中，我们将会看到Spring Boot Actuator的几个样例，它开启了一扇窗，能够让我们洞悉应用的内部运行状况。</p>
<p>现在，我们对Spring Boot的四个主要特性已经有了基本的了解，接下来我们将使用它们构建一个微小但完整的应用程序。</p>
<h1>使用Spring Boot构建应用</h1>
<p>现在，我将会向你展现如何使用Spring Boot构建完整且符合现实要求（real-world）的应用程序。当然，“符合现实要求”的定义标准会有些争议，对它的讨论超出了本章的范围。因此，与其在这里说构建符合现实要求的应用，还不如后退一步，说成我们所构建的应用程序比现实要求稍差一点，但是它能够代表使用Spring Boot所构建的更大型应用。</p>
<p>我们的应用是一个简单的联系人列表。它允许用户输入联系人信息（名字、电话号码以及Email地址），并且能够列出用户之前输入的所有联系人信息。</p>
<p>你可以自由选择使用Maven还是Gradle来构建应用程序，我更喜欢Gradle，但是如果你喜欢Maven的话，我也将会列出所需的Maven代码。如下的程序清单展现了起始的build.gradle文件。开始的时候，依赖部分是空的，但是在这个过程中，我们将会使用依赖填充这部分的内容。</p>
<p><img src="https://hexo-1300861231.cos.ap-shanghai.myqcloud.com/1584862924_20200322153654745_21905.jpg" alt></p>
<p>注意，构建中包含对Spring Boot Gradle的buildscript依赖。稍后将会看到，这会帮助我们生成一个可执行的超级JAR文件（uber-JAR），这个文件中将会包含应用的所有依赖。</p>
<p>如果你更喜欢Maven的话，如下的程序清单展现了完整的pom.xml文件。</p>
<p><img src="https://hexo-1300861231.cos.ap-shanghai.myqcloud.com/1584862924_20200322153654523_31827.jpg" alt></p>
<p>与Gradle构建类似，这个Maven的pom.xml文件使用了Spring Boot Maven插件。这个Maven中的插件对应于Gradle插件，能够生成可执行的超级JAR文件。</p>
<p>同样需要注意的是， <strong>与Gradle构建不同，Maven构架有一个parent项目。我们让项目的Maven构建基于Spring Boot starter parent，这样的话，我们就能受益于Maven的依赖管理功能，对于项目中的很多依赖，就没有必要明确声明版本号了，因为版本号会从parent中继承得到。</strong></p>
<p>按照Maven和Gradle项目的标准结构，完成后项目将会如下所示：</p>
<p><img src="https://hexo-1300861231.cos.ap-shanghai.myqcloud.com/1584862924_20200322153654197_20734.png" alt></p>
<p>不要担心现在缺失Java和其他的资源文件。在开发Contacts应用的过程中，我们将会在下面的几个小节中创建这些文件，首先将会从构建应用的Web层开始。</p>
<h2 id="处理Web请求">处理Web请求</h2>
<p>因为我们要使用Spring MVC来开发应用的Web层，因此需要将Spring MVC作为依赖添加到构建中。我们已经讨论过，Spring Boot的Web Starter能够将Spring MVC需要的所有内容一站式添加到构建中。如下是我们所需的Gradle依赖：</p>
<p><img src="https://hexo-1300861231.cos.ap-shanghai.myqcloud.com/1584862924_20200322153653975_15227.png" alt></p>
<p>如果使用Maven来进行构建的话，那么依赖将会如下所示；</p>
<p><img src="https://hexo-1300861231.cos.ap-shanghai.myqcloud.com/1584862923_20200322153653762_8382.png" alt></p>
<p>注意，因为Spring Boot parent项目已经指定了Web Starter依赖的版本，因此在项目的build.gradle和pom.xml文件中没有必要再显式指定版本信息。</p>
<p>Web Starter依赖就绪之后，使用Spring MVC需要的所有依赖都会添加到项目中。现在，我们就可以编写应用所需的控制器类了。</p>
<p>控制器相对会非常简单，包含展现联系人表单的HTTP GET请求以及处理表单提交的POST请求。它本身并没有做太多的事情，而是委托ContactRepository（稍后就会创建它）来持久化联系人信息。下面程序清单中的ContactController就能满足这些需求。</p>
<p><img src="https://hexo-1300861231.cos.ap-shanghai.myqcloud.com/1584862923_20200322153653548_25937.jpg" alt></p>
<p>你首先可能会发现ContactController就是一个典型的Spring MVC控制器。尽管Spring Boot会管理构建依赖并最小化Spring配置，但是在编写应用逻辑的时候，编程模型是一致的。</p>
<p>在本例中，ContactController遵循了Spring MVC控制器的典型模式，它会展现表单并处理表单的提交。其中home()方法使用注入的ContactRepository来获取所有Contact对象的列表，并将它们放到模型中，然后把请求转交给home视图。这个视图将会展现联系人的列表以及添加新Contact的表单。submit()方法将会处理表单提交的POST请求，保存Contact，并重定向到首页。</p>
<p>因为ContactController使用了@Controller注解，所以组件扫描将会找到它。因此，我们不需要在Spring应用上下文中明确将其声明为bean。</p>
<p>而Contact模型类是一个简单的POJO，具有一些属性和存取器方法，如下面的程序清单所示。</p>
<p><img src="https://hexo-1300861231.cos.ap-shanghai.myqcloud.com/1584862923_20200322153653222_7947.jpg" alt></p>
<p>应用程序的Web层基本上已经完成了，剩下的就是创建定义home视图的Thymeleaf模板。</p>
<h2 id="创建视图">创建视图</h2>
<p>按照传统的方式，Java Web应用会使用JSP作为视图层的技术。但是，如前所述，在这个领域有一个新的参与者。Thymeleaf的原生模板比JSP更加便于使用，而且它能够让我们以HTML的形式编写模板。鉴于此，我们将会使用Thymeleaf来定义Contacts应用的home视图。</p>
<p>首先，需要将Thymeleaf添加到项目的构建中。在本例中，我使用的是Spring 4，所以需要将Thymeleaf的Spring 4模块添加到构建之中。在Gradle中，依赖将会如下所示：</p>
<p><img src="https://hexo-1300861231.cos.ap-shanghai.myqcloud.com/1584862923_20200322153652888_11563.png" alt></p>
<p>如果使用Maven的话，所需的依赖如下所示：</p>
<p><img src="https://hexo-1300861231.cos.ap-shanghai.myqcloud.com/1584862922_20200322153652675_10260.png" alt></p>
<p><strong>需要记住的是，只要我们将Thymeleaf添加到项目的类路径下，就启用了Spring Boot的自动配置。</strong> 当应用运行时，Spring Boot将会探测到类路径中的Thymeleaf，然后会自动配置视图解析器、模板解析器以及模板引擎，这些都是在Spring MVC中使用Thymeleaf所需要的。因此，在我们的应用中，不需要使用显式Spring配置的方式来定义Thymeleaf。</p>
<p>除了将Thymeleaf依赖添加到构建中，我们剩下所需要做的就是定义视图模板。下面程序清单展现了home.html，这是定义home视图的Thymeleaf模板。</p>
<p><img src="https://hexo-1300861231.cos.ap-shanghai.myqcloud.com/1584862922_20200322153652459_13179.jpg" alt></p>
<p>它实际上是一个非常简单的Thymeleaf模板，分为两部分：一个表单和一个联系人的列表。表单将会POST数据到ContactController的submit()方法上，用来创建新的Contact。列表部分将会循环列出模型中的Contact对象。</p>
<p>为了使用这个模板，我们需要对其进行慎重地命名并放在项目的正确位置下。因为ContactController中home()方法所返回的逻辑视图名为home，因此模板文件应该命名为home.html， <strong>自动配置的模板解析器会在指定的目录下查找Thymeleaf模板，这个目录也就是相对于根类路径下的templates目录下，所以在Maven或Gradle项目中，我们需要将home.html放到“src/main/ resources/templates”中。</strong></p>
<p>这个模板还有一点小事情需要处理，它所产生的HTML将会引用名为style.css的样式表。因此，需要将这个样式表放到项目中。</p>
<h3 id="添加静态内容">添加静态内容</h3>
<p>正常来讲，在编写Spring应用时，我会尽量避免讨论样式和图片。当然，这些内容能够在很大程度上让各种应用（包括Spring应用）变得更加美观，令用户赏心悦目。但是，对于编写服务器端的Spring代码来说，这些静态内容就没有那么重要了。</p>
<p>但是，在Spring Boot中，有必要讨论一下它是如何处理静态内容的。 <strong>当采用Spring Boot的Web自动配置来定义Spring MVC bean时，这些bean中会包含一个资源处理器（resource handler），它会将“/**”映射到几个资源路径中。</strong> 这些资源路径包括（相对于类路径的根）：</p>
<ul>
<li>/META-INF/resources/</li>
<li>/resources/</li>
<li>/static/</li>
<li>/public/</li>
</ul>
<p>在传统的基于Maven/Gradle构建的项目中，我们通常会将静态内容放在“src/main/webapp”目录下，这样在构建所生成的WAR文件里面，这些内容就会位于WAR文件的根目录下。如果使用Spring Boot构建WAR文件的话，这依然是可选的方案。但是，我们也可以将静态内容放在资源处理器所映射的上述四个路径下。</p>
<p>所以，为了满足Thymeleaf模板对“/style.css”文件的引用，我们需要创建一个名为style.css文件，并将其放到如下所示的某一个位置中：</p>
<ul>
<li>/META-INF/resources/style.css</li>
<li>/resources/style.css</li>
<li>/static/style.css</li>
<li>/public/style.css</li>
</ul>
<p>具体的选择完全取决于你，我倾向于将静态内容放到“/public”中，不过这四个可选方案是等价的。</p>
<p>不管你是否相信，对于这个简单的Contacts应用来说，我们已经完成了超过一半的任务！Web层全部完成了，接下来我们需要创建ContactRepository，用来处理Contact对象的持久化。</p>
<h2 id="持久化数据">持久化数据</h2>
<p>在Spring应用中，有多种使用数据库的方式。我们可以使用JPA或Hibernate将对象映射为关系型数据库中的表和列。或者，我们干脆放弃关系型数据库，使用其他类型的数据库，如Mongo或Neo4j。</p>
<p>对于Contacts应用来说，关系型数据库是不错的选择。我们将会使用H2数据库和JDBC（使用Spring的JdbcTemplate），让这个过程尽可能地简单。</p>
<p>选择这种方案就需要在构建中添加一些依赖。JDBC Starter依赖会将Spring JdbcTemplate需要的所有内容都引入进来。不过，要结合使用H2数据库的话，我们还需要添加H2依赖。如果使用Gradle的话，在dependencies代码块添加如下两行代码就能完成这项任务：</p>
<p><img src="https://hexo-1300861231.cos.ap-shanghai.myqcloud.com/1584862922_20200322153652132_15023.png" alt></p>
<p>如果使用Maven构建的话，我们需要如下的两个 <code>&lt;dependency&gt;</code> 代码块：</p>
<p><img src="https://hexo-1300861231.cos.ap-shanghai.myqcloud.com/1584862922_20200322153651917_26144.png" alt></p>
<p>将这两项依赖添加到构建之中后，我们就可以编写Repository类了。如下程序清单中的ContactRepository将会使用注入的JdbcTemplate实现在数据库中读取和写入Contact对象。</p>
<p><img src="https://hexo-1300861231.cos.ap-shanghai.myqcloud.com/1584862921_20200322153651701_883.jpg" alt></p>
<p>与ContactController类似，这个Repository类非常简单。它与传统Spring应用中的Repository类并没有什么差别。从实现中，根本无法看出它要用于Spring Boot的应用程序中。findAll()方法使用注入的JdbcTemplate从数据库中获取Contact对象，save()方法使用注入的JdbcTemplate保存新的Contact对象。因为ContactRepository使用了@Repository注解，因此在组件扫描的时候，它会被发现并创建为Spring应用上下文中的bean。</p>
<p>但是，JdbcTemplate呢？我们难道不需要在Spring应用上下文中声明JdbcTemplatebean吗？为了声明它，我们是不是还要声明一个H2 DataSource？</p>
<p>对这两个问题的简短问答就是“不需要”。当Spring Boot探测到Spring的JDBC模块和H2在类路径下的时候，自动配置就会发挥作用，将会自动配置JdbcTemplate bean和H2DataSource bean。Spring Boot再一次为我们处理了所有的Spring配置。</p>
<p>那数据库模式该怎么处理呢？我们必须要自己来定义创建contacts表的模式，对不对？</p>
<p>这绝对是正确的！Spring Boot没有办法猜测contacts表会是什么样子。所以，我们需要定义模式，如下所示：</p>
<p><img src="https://hexo-1300861231.cos.ap-shanghai.myqcloud.com/1584862921_20200322153651271_1573.png" alt></p>
<p>现在，我们只需要有一种方式加载这个“create table”的SQL并将其在H2数据库中执行就可以了。幸好，Spring Boot也涵盖了这项功能。如果我们将这个文件命名为schema.sql并将其放在类路径根下（也就是Maven或Gradle项目的“src/main/resources”目录下），当应用启动的时候，就会找到这个文件并进项数据加载。</p>
<h2 id="尝试运行">尝试运行</h2>
<p>Contacts应用非常简单，但是也算得上现实中的Spring应用。它具有Spring MVC控制器和Thymeleaf模板所定义的Web层，并且具有Repository和Spring JdbcTemplate所定义的持久层。</p>
<p>到此为止，我们已经编写完了Contacts所需的应用级别代码。不过，我们还没有编写任何形式的配置。我们没有编写任何Spring配置，也没有在web.xml或Servlet初始化类中配置DispatcherServlet。</p>
<p>如果我说不需要编写任何的配置，你会相信吗？</p>
<p>这应该做不到吧，毕竟在对Spring的批评中，人们都在说Spring全是配置，肯定有我们忽略掉的XML文件或Java配置类。我们所编写的Spring应用程序根本就不可能没有任何配置的……那么，我们到底能做到吗？</p>
<p>通常来讲，Spring Boot的自动配置特性消除了绝大部分或者全部的配置。因此，完全可能编写出没有任何配置的Spring应用程序。当然，自动配置并不能涵盖所有的场景，因此典型的Spring Boot应用程序依然会需要一点配置。具体到Contacts应用，我们不需要任何的配置。Spring的自动配置功能已经将所有的事情都做好了。</p>
<p>但是，我们需要有个特殊的类来启动Spring Boot应用。Spring本身并不知道自动配置的任何信息。下面程序清单中的Application类就是Spring Boot启动类的典型例子。</p>
<p><img src="https://hexo-1300861231.cos.ap-shanghai.myqcloud.com/1584862921_20200322153650957_25423.jpg" alt></p>
<p>好吧，我承认Application中有那么一点配置。它使用@ComponentScan注解来启用组件扫描，另外它还使用了@EnableAutoConfiguration，这会启用Spring Boot的自动配置特性。但是，也就这么多了！除了这两行代码以外，Contacts再也没有什么配置了。</p>
<p>Application类最有意思的一点在于它具有一个main()方法。稍后将会看到，Spring Boot应用会以一种特殊的方法运行，正是这里的main()方法使这一切成为可能。 <strong>在main()方法中，这行代码会告诉Spring Boot（通过SpringApplication类）根据Application中的配置以及命令行中的参数来运行。</strong></p>
<p>现在，我们马上就可以运行应用了。剩下就是要进行构建。如果使用Gradle的话，那么如下的命令行会将项目构建到“build/libs/contacts-0.1.0.jar”中：</p>
<p><img src="https://hexo-1300861231.cos.ap-shanghai.myqcloud.com/1584862921_20200322153650738_7390.png" alt></p>
<p>如果你喜欢Maven的话，那么可以按照如下的方式构建项目：</p>
<p><img src="https://hexo-1300861231.cos.ap-shanghai.myqcloud.com/1584862921_20200322153650526_17156.png" alt></p>
<p>运行Maven构建后，你会在target文件夹下找到构建形成的结果。</p>
<p>现在，我们就可以运行它了。按照传统的方式，这意味着要将应用的WAR文件部署到Servlet容器中，如Tomcat或WebSphere。但是在这里，我们甚至没有WAR文件——构建形成的是一个JAR文件。</p>
<p>这没有什么问题。我们可以按照如下的方式从命令行运行它（引用的是基于Gradle构建的JAR文件）：</p>
<p><img src="https://hexo-1300861231.cos.ap-shanghai.myqcloud.com/1584862920_20200322153650314_26057.png" alt></p>
<p>在几秒钟后，应用应该已经启动完成并且可以访问了。打开浏览器进入<a href="http://localhost:8080/" target="_blank" rel="noopener">http://localhost:8080</a>，你就应该可以输入联系人了。在输入几个联系人后，浏览器将会如图所示。</p>
<p>你可能觉得这并不符合Web应用的运行方式。像这样从命令行运行应用非常简洁和方便，但是，对于你来讲，也许这并不理想。在你所工作的环境中，有可能需要将Web应用作为WAR文件部署到Web容器中。如果不提交WAR文件的话，可能不满足公司的部署策略。</p>
<p><img src="https://hexo-1300861231.cos.ap-shanghai.myqcloud.com/1584862920_20200322153650101_7990.png" alt></p>
<p>好的，那也没有问题。</p>
<p>即便是对于生产环境，通过命令行来运行应用也是合理的方案，但是我理解你可能需要遵循公司的部署流程。这意味着需要构建和部署WAR文件。</p>
<p>好消息是，如果你需要WAR文件的话，并没有必要舍弃Spring Boot的简洁性。需要做的事情仅仅是稍微调整一下构建文件。在Gradle构建中，我们需要添加如下这行代码来应用“war”插件：</p>
<p><img src="https://hexo-1300861231.cos.ap-shanghai.myqcloud.com/1584862920_20200322153649373_16287.png" alt></p>
<p>除此之外，还需要将“jar”配置调整为“war”。这实际上就是将“j”替换为“w”：</p>
<p><img src="https://hexo-1300861231.cos.ap-shanghai.myqcloud.com/1584862920_20200322153649161_15608.png" alt></p>
<p>如果是Maven构建的项目，那会更加简单。只需将packaging从“jar”替换为“war”即可：</p>
<p><img src="https://hexo-1300861231.cos.ap-shanghai.myqcloud.com/1584862919_20200322153648949_26231.png" alt></p>
<p>现在，我们可以重新构建项目，然后将会在构建目录中找到contacts-0.1.0.war文件。这个WAR文件文件可以部署到任意支持Servlet 3.0的容器中。另外，我们依然可以在命令行中运行这个应用：</p>
<p><img src="https://hexo-1300861231.cos.ap-shanghai.myqcloud.com/1584862919_20200322153648737_29938.png" alt></p>
<p><strong>没错：这是一个可运行的WAR文件！对于两种场景来说，这都是最佳的方案。</strong></p>
<p>我们可以看到，Spring Boot能够在很大程度上尽可能简化Spring应用的部署。Spring Boot Stater简化了项目构建的依赖，自动配置消除了显式的Spring配置。但稍后你会看到，如果再结合Groovy，它会更加简单。</p>
<h1>组合使用Groovy与Spring Boot CLI</h1>
<p>Groovy编程语言要比Java简单得多。它的语法允许有一些快捷方式，比如省略分号和public关键词。同时，Groovy类中的属性不像Java那样需要Setter和Getter方法。当然，Groovy还有其他的一些属性，能够消除Java代码中很多的繁文缛节。</p>
<p>如果你愿意使用Groovy编写应用代码并通过Spring Boot CLI运行的话，那么Spring Boot能够借助Groovy的简洁性进一步简化Spring应用。为了阐述这一点，我们使用Groovy来重新编写Contacts应用程序。</p>
<p>为什么不呢？在初始版本的应用中，我们只有几个小的Java类，因此使用Groovy进行重写也没有太多的工作量。我们可以重用相同的Thymeleaf模板和schema.sql文件。既然我宣称Groovy能够进一步简化Spring，那重写应用也不是什么大事儿。</p>
<p>在这个过程中，我们还会移除一些代码。Spring Boot CLI本身就是启动器，所以不再需要前面所创建的Application类。Maven和Gradle构建文件也不再需要了，因为我们将会通过CLI运行未编译的Groovy文件。少了Maven和Gradle之后，项目的整体结构将会变得更加扁平化，新的项目结构将会如下所示：</p>
<p><img src="https://hexo-1300861231.cos.ap-shanghai.myqcloud.com/1584862919_20200322153648519_23016.png" alt></p>
<p>schema.sql、style.css和home.html将会保持原样，但是需要将Java类转换为Groovy。我们先从使用Groovy编写Web层开始。</p>
<h2 id="编写Groovy控制器">编写Groovy控制器</h2>
<p>如前所述，Groovy不像Java那样有很多的繁文缛节。这意味着我们在编写Groovy代码的时候，可以省略如下的内容：</p>
<ul>
<li>分号；</li>
<li>像public和private这样的修饰符；</li>
<li>属性的Setter和Getter方法；</li>
<li>方法返回值的return关键字。</li>
</ul>
<p>借助Groovy更加灵活的语法（以及Spring Boot的魔力），我们可以使用Groovy重写ContactController类，如下面程序清单所示。</p>
<p><img src="https://hexo-1300861231.cos.ap-shanghai.myqcloud.com/1584862919_20200322153648305_2965.jpg" alt></p>
<p>我们可以看到，这个版本的ContactController要比对应的Java版本更加简洁。排除掉Groovy不需要的内容后，ContactController更加简短也更易于阅读。</p>
<p>上面程序清单还移除了一些内容，你可能也发现了，这里没有import代码行，在Java代码中这是很常见的。Groovy默认会导入一些包和类，包括：</p>
<ul>
<li><a href="http://java.io" target="_blank" rel="noopener">java.io</a>.*</li>
<li>java.lang.*</li>
<li>java.math.BigDecimal</li>
<li>java.math.BigInteger</li>
<li><a href="http://java.net" target="_blank" rel="noopener">java.net</a>.*</li>
<li>java.util.*</li>
<li>groovy.lang.*</li>
<li>groovy.util.*</li>
</ul>
<p>因为有了这些默认的导入，所以ContactController就不需要导入List类了。这个类位于java.util包中，包含在默认的导入里面。</p>
<p>但是，像@Controller、@RequestMapping、@Autowired以及@RequestMethod这样的Spring类型该怎么处理呢？它们没有位于默认的导入中，我们该如何省略import代码行呢？</p>
<p>稍后，当我们运行应用的时候，Spring Boot CLI将会试图使用Groovy编译器编译这些Groovy类。因为这些类型没有导入进来，所以将会导致编译失败。</p>
<p>但是，Spring Boot CLI却不会就这样轻易放弃，在这里CLI将自动配置达到了一个新高度。 <strong>CLI将会识别出失败是因为缺少Spring类型，它会采取两个步骤来修正这个问题。首先会获取Spring Boot Web Starter依赖并将其依赖的其他内容都添加到类路径下（这样会下载并添加JAR到类路径下）。然后，它会将必要的包添加到Groovy编译器的默认导入列表中，然后重新尝试编译代码。</strong></p>
<p>CLI这种自动添加依赖/自动导入的结果就是我们的控制器类不需要任何的import语句了，并且我们没有必要再手动或者通过Maven、Gradle来解析Spring库。Spring Boot CLI将会为我们完成所有的事情。</p>
<p>现在，让我们后退一步，考虑一下这里都发生了什么。通过在代码中使用Spring MVC类型，如@Controller或@RequestMapping，CLI将会自动解析Spring Boot Web Starter依赖。将Web Starter的依赖传递添加到类路径之后，Spring Boot的自动配置将会发挥作用，它会为我们自动配置Spring MVC功能所需的bean。不过，在这里我们需要做的仅仅是使用这些类型，Spring Boot将会处理所有的事情。</p>
<p>当然，CLI的功能也会有一些限制。 <strong>尽管它知道如何解析众多的Spring依赖，并且能够自动将很多Spring类型（以及很多其他的库）添加到导入中，但是它不能自动解析和导入所有的功能。例如，使用Thymeleaf模板是一个可替换的方案，所以要在代码中通过@Grab显示声明。</strong></p>
<p>还要注意，很多的依赖都没有必要指定group ID和版本号。Spring Boot将会在解析@Grab依赖的时候参与进来，将缺失的group ID和版本号添加上。</p>
<p>借助@Grab注解，我们声明了要使用Thymeleaf，这会触发自动配置功能，将会自动配置在Spring MVC中支持Thymeleaf模板所需的bean。</p>
<p>尽管Contact类与Spring Boot没有太大关系，但为了样例的完整性，我还是将它的Groovy代码展现在了下面：</p>
<p><img src="https://hexo-1300861231.cos.ap-shanghai.myqcloud.com/1584862919_20200322153648086_13708.png" alt></p>
<p>可以看到，Contact也更加简洁，没有分号、存取器方法以及像public和private这样的修饰符。这完全归功于Groovy简单的语法，其实Spring Boot并没有参与简化Contact类。</p>
<p>接下来，我们看一下如何借助Spring Boot CLI和Groovy来简化Repository类。</p>
<h2 id="使用Groovy-Repository实现数据持久化">使用Groovy Repository实现数据持久化</h2>
<p>ContactController中所用到的Groovy和Spring Boot CLI技巧都可以应用到ContactRepository中。如下的程序清单展现了Groovy版本的ContactRepository。</p>
<p><img src="https://hexo-1300861231.cos.ap-shanghai.myqcloud.com/1584862918_20200322153647873_12030.jpg" alt></p>
<p>除了Groovy在语法方面带来的明显改善，这个新版的ContactRepository类使用了Spring Boot CLI自动导入JdbcTemplate和RowMapper。除此之外，当CLI发现我们使用这些类型的时候，将会自动解析JDBC Starter依赖。</p>
<p>只有两件事情是CLI的自动导入和自动解析无法帮助我们的。可以看到，我们依然需要导入ResultSet。另外，Spring Boot无法知道我们使用哪种数据库，因此必须要使用@Grab注解添加H2数据库。</p>
<p>我们已经将所有Java类转换成了Groovy并在这个过程中发挥了Spring Boot的魔力。现在，我们可以运行应用了。</p>
<h2 id="安装并运行Spring-Boot-CLI">安装并运行Spring Boot CLI</h2>
<p>在编译完Java应用之后，有两种方法来运行它。我们可以按照可执行JAR或WAR文件的形式在命令行运行，也可以将WAR文件部署到Servlet容器中运行。Spring Boot CLI提供了第三种可选方案。</p>
<p>从名字应该也能猜得出来，通过Spring Boot CLI运行应用需要使用命令行。但是，借助CLI，我们不需要首先将应用构建为JAR或WAR文件。运行应用的时候，我们可以直接将Groovy源码传给CLI。</p>
<h3 id="安装CLI">安装CLI</h3>
<p>为了使用Spring Boot CLI，我们需要安装它。有多种方案可供选择，包括：</p>
<ul>
<li>Groovy环境管理器（Groovy Environment Manager ，GVM）；</li>
<li>Homebrew；</li>
<li>手动安装。</li>
</ul>
<p>如果使用GVM安装CLI的话，输入以下命令：</p>
<p><img src="https://hexo-1300861231.cos.ap-shanghai.myqcloud.com/1584862918_20200322153647550_14169.png" alt></p>
<p>你如果使用OS X的话，我们可以使用Homebrew来安装Spring Boot CLI：</p>
<p><img src="https://hexo-1300861231.cos.ap-shanghai.myqcloud.com/1584862918_20200322153647338_32627.png" alt></p>
<p>如果你愿意手动安装Spring Boot的话，那么可以下载并按照该站点<a href="http://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/" target="_blank" rel="noopener">http://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/</a>的指南进行安装。</p>
<p>CLI安装完成之后，可以使用如下的命令检查安装情况以及当前使用的是哪个版本：</p>
<p><img src="https://hexo-1300861231.cos.ap-shanghai.myqcloud.com/1584862918_20200322153647127_1698.png" alt></p>
<p>假设安装没有问题的话，那就可以运行Contacts应用了。</p>
<h3 id="使用CLI运行Contacts应用">使用CLI运行Contacts应用</h3>
<p>要使用Spring Boot CLI运行应用的话，我们需要在命令行输入spring run，然后后面再加上要通过CLI运行的一个或多个Groovy文件。例如，如果应用只有一个Groovy文件的话，那么可以这样运行：</p>
<p><img src="https://hexo-1300861231.cos.ap-shanghai.myqcloud.com/1584862917_20200322153646916_3489.png" alt></p>
<p>这样就会通过CLI运行一个名为Hello.groovy的Groovy类。</p>
<p>如果你的应用有多个Groovy类文件的话，那么可以通过通配符来运行，如下所示；</p>
<p><img src="https://hexo-1300861231.cos.ap-shanghai.myqcloud.com/1584862917_20200322153646704_22467.png" alt></p>
<p>或者，如果这些Groovy类文件位于同一个或多个子目录下，那么我们可以使用Ant风格的通配符递归查找Groovy类：</p>
<p><img src="https://hexo-1300861231.cos.ap-shanghai.myqcloud.com/1584862917_20200322153646493_2562.png" alt></p>
<p>因为Contacts应用有三个需要读取的Groovy类，而且它们都位于项目的根目录下，所以上述的后两种方案都是可行的。在运行应用之后，我们就能够在浏览器中访问<a href="http://localhost:8080/" target="_blank" rel="noopener">http://localhost:8080</a>，并且能够在浏览器中看到与之前相同的Contacts应用。</p>
<p>到此为止，我们以两种方式编写了Spring Boot应用：一种使用Java，另一种使用Groovy。在这两种情况中，Spring Boot在最小化模板配置以及构建依赖方面都发挥了很大的作用。Spring Boot还有另外一项功能。让我们看一下如何借助Spring Boot Actuator为Web应用引入管理端点。</p>
<h1>通过Actuator获取了解应用内部状况</h1>
<p>Spring Boot Actuator所完成的主要功能就是为基于Spring Boot的应用添加多个有用的管理端点。这些端点包括以下几个内容。</p>
<ul>
<li>GET /autoconfig：描述了Spring Boot在使用自动配置的时候，所做出的决策；</li>
<li>GET /beans：列出运行应用所配置的bean；</li>
<li>GET /configprops：列出应用中能够用来配置bean的所有属性及其当前的值；</li>
<li>GET /dump：列出应用的线程，包括每个线程的栈跟踪信息；</li>
<li>GET /env：列出应用上下文中所有可用的环境和系统属性变量；</li>
<li>GET /env/{name}：展现某个特定环境变量和属性变量的值；</li>
<li>GET /health：展现当前应用的健康状况；</li>
<li>GET /info：展现应用特定的信息；</li>
<li>GET /metrics：列出应用相关的指标，包括请求特定端点的运行次数；</li>
<li>GET /metrics/{name}：展现应用特定指标项的指标状况；</li>
<li>POST /shutdown：强制关闭应用；</li>
<li>GET /trace：列出应用最近请求相关的元数据，包括请求和响应头。</li>
</ul>
<p>为了启用Actuator，我们只需将Actuator Starter依赖添加到项目中即可。如果你使用Groovy编写应用并通过Spring Boot CLI来运行，那么可以通过@Grab注解来添加Actuator Starter，如下所示：</p>
<p><img src="https://hexo-1300861231.cos.ap-shanghai.myqcloud.com/1584862917_20200322153646282_5063.png" alt></p>
<p>如果使用Gradle构建Java应用的话，那么在build.gradle的dependencies代码块中需要添加如下的依赖：</p>
<p><img src="https://hexo-1300861231.cos.ap-shanghai.myqcloud.com/1584862917_20200322153646071_2837.png" alt></p>
<p>或者，在项目的Maven pom.xml文件中，我们可以添加如下的 <code>&lt;dependency&gt;</code> ：</p>
<p><img src="https://hexo-1300861231.cos.ap-shanghai.myqcloud.com/1584862916_20200322153645859_2175.png" alt></p>
<p>添加完Spring Boot Actuator之后，我们可以重新构建并启动应用，然后打开浏览器访问以上所述的端点来获取更多信息。例如，如果想要查看Spring应用上下文中所有的bean，那么可以访问<a href="http://localhost:8080/beans" target="_blank" rel="noopener">http://localhost:8080/beans</a>。如果使用curl命令行工具的话，所得到的结果将会如下所示（为了便于阅读，进行了格式化和删减）：</p>
<p><img src="https://hexo-1300861231.cos.ap-shanghai.myqcloud.com/1584862916_20200322153645647_25679.png" alt></p>
<p>从这里，我们可以看到有一个ID为contactController的bean，它依赖于名为contactRepository的bean，而contactRepository又依赖于jdbcTemplatebean。</p>
<p>因为我对输出进行了删减，所以有很多的bean没有展现出来，它们都包含在“/beans”端点所产生的JSON中。对于自动装配和自动配置所形成的神秘结果，这里提供了一种了解内部实现的手段。</p>
<p>另外一个端点也能帮助我们了解Spring Boot自动配置的内部情况，这就是“/autoconfig”。这个端点所返回的JSON描述了Spring Boot在自动配置bean的时候所做出的决策。例如，当针对Contacts应用调用“/autoconfig”端点时，如下展现了删减后（并进行了格式化）的JSON结果：</p>
<p><img src="https://hexo-1300861231.cos.ap-shanghai.myqcloud.com/1584862916_20200322153645390_9457.jpg" alt></p>
<p>我们可以看到，这个报告包含了两部分：一部分是没有匹配上的（negative matches），另一部分是匹配上的（positive matches）。在没有匹配的部分中，表明没有使用AOP和自动配置，因为在类路径中没有找到所需的类。在匹配上的部分中，我们可以看到，因为在类路径下找到了SpringTemplateEngine，Thymeleaf自动配置将会发挥作用。同时还可以看到，除非明确声明了默认的模板解析器、视图解析器以及模板bean否则的话，这些bean会进行自动配置。另外，只有在类路径中能够找到Servlet类，才会自动配置默认的视图解析器。</p>
<p>“/beans”和“/autoconfig”端点只是Spring Boot Actuator所提供的观察应用内部状况的两个样例。在本章中，我们没有足够的篇幅详细讨论每个端点，但是我建议你自行尝试这些端点，以便掌握Actuator都提供了哪些功能来帮助我们了解应用的内部状况。</p>

      </div>
      
      
      
    </div>
    
  <ul class="breadcrumb">
          
            <li><a href="/quotes/">QUOTES</a></li>
            <li><a href="/quotes/Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">SPRING学习笔记</a></li>
            <li>55-借助SPRINGBOOT简化SPRING开发</li>
          
  </ul>

    
    
    
  </div>


          </div>
          

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#null"><span class="nav-text">Spring Boot简介</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#添加Starter依赖"><span class="nav-text">添加Starter依赖</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#自动配置"><span class="nav-text">自动配置</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Spring-Boot-CLI"><span class="nav-text">Spring Boot CLI</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Actuator"><span class="nav-text">Actuator</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#null"><span class="nav-text">使用Spring Boot构建应用</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#处理Web请求"><span class="nav-text">处理Web请求</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#创建视图"><span class="nav-text">创建视图</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#添加静态内容"><span class="nav-text">添加静态内容</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#持久化数据"><span class="nav-text">持久化数据</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#尝试运行"><span class="nav-text">尝试运行</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#null"><span class="nav-text">组合使用Groovy与Spring Boot CLI</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#编写Groovy控制器"><span class="nav-text">编写Groovy控制器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用Groovy-Repository实现数据持久化"><span class="nav-text">使用Groovy Repository实现数据持久化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#安装并运行Spring-Boot-CLI"><span class="nav-text">安装并运行Spring Boot CLI</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#安装CLI"><span class="nav-text">安装CLI</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用CLI运行Contacts应用"><span class="nav-text">使用CLI运行Contacts应用</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#null"><span class="nav-text">通过Actuator获取了解应用内部状况</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <img class="site-author-image" itemprop="image" alt="jiateng.jiang"
    src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">jiateng.jiang</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">44</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">32</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">jiateng.jiang</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v4.0.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.4.2
  </div>

        












        
      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/pisces.js"></script>
<script src="/js/next-boot.js"></script>



  






  <script src="/js/local-search.js"></script>








<script>
if (document.querySelectorAll('div.pdf').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/pdfobject@2/pdfobject.min.js', () => {
    document.querySelectorAll('div.pdf').forEach(element => {
      PDFObject.embed(element.getAttribute('target'), element, {
        pdfOpenParams: {
          navpanes: 0,
          toolbar: 0,
          statusbar: 0,
          pagemode: 'thumbs',
          view: 'FitH'
        },
        PDFJS_URL: '/lib/pdf/web/viewer.html',
        height: element.getAttribute('height') || '100%'
      });
    });
  }, window.PDFObject);
}
</script>





  

  

  

</body>
</html>
