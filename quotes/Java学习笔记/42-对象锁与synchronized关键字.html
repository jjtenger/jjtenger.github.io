<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '7.4.2',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: true,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"manual","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.json',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    },
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="1.synchronized锁在多线程环境中，可能会有两个甚至更多的线程试图同时访问一个有限的资源。比如对同一个对象的成员变量进行操作时，他们对该成员变量是彼此影响的（也就是说一个线程对成员变量的改变会影响到另一个线程）。必须对这种潜在资源冲突进行预防。（一个线程对线程内部的局部变量的改变不会影响到其他的线程。）">
<meta property="og:type" content="website">
<meta property="og:title" content="JJT-个人Wiki">
<meta property="og:url" content="https:&#x2F;&#x2F;hexo-pages-1300861231.cos-website.ap-shanghai.myqcloud.com&#x2F;quotes&#x2F;Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0&#x2F;42-%E5%AF%B9%E8%B1%A1%E9%94%81%E4%B8%8Esynchronized%E5%85%B3%E9%94%AE%E5%AD%97.html">
<meta property="og:site_name" content="JJT-个人Wiki">
<meta property="og:description" content="1.synchronized锁在多线程环境中，可能会有两个甚至更多的线程试图同时访问一个有限的资源。比如对同一个对象的成员变量进行操作时，他们对该成员变量是彼此影响的（也就是说一个线程对成员变量的改变会影响到另一个线程）。必须对这种潜在资源冲突进行预防。（一个线程对线程内部的局部变量的改变不会影响到其他的线程。）">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https:&#x2F;&#x2F;hexo-1300861231.cos.ap-shanghai.myqcloud.com&#x2F;1584757125_20200321101433686_12374.png">
<meta property="og:updated_time" content="2020-12-15T11:07:33.024Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https:&#x2F;&#x2F;hexo-1300861231.cos.ap-shanghai.myqcloud.com&#x2F;1584757125_20200321101433686_12374.png">

<link rel="canonical" href="https://hexo-pages-1300861231.cos-website.ap-shanghai.myqcloud.com/quotes/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/42-%E5%AF%B9%E8%B1%A1%E9%94%81%E4%B8%8Esynchronized%E5%85%B3%E9%94%AE%E5%AD%97">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: false,
    isPage: true,
    isArchive: false
  };
</script>

  <title> | JJT-个人Wiki
  </title>
  








  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">JJT-个人Wiki</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">you see see you one day day</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="搜索..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
  
  

          <div class="content">
            

  <div class="posts-expand">
    
    
    
    <div class="post-block" lang="zh-CN">
      <header class="post-header">

<h1 class="post-title" itemprop="name headline">
</h1>

<div class="post-meta">
  
  <ul class="breadcrumb">
          
            <li><a href="/quotes/">QUOTES</a></li>
            <li><a href="/quotes/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">JAVA学习笔记</a></li>
            <li>42-对象锁与SYNCHRONIZED关键字</li>
          
  </ul>

</div>

</header>

      
      
      
      <div class="post-body">
          <h1>1.synchronized锁</h1><p>在多线程环境中，可能会有两个甚至更多的线程试图同时访问一个有限的资源。比如对同一个对象的成员变量进行操作时，他们对该成员变量是彼此影响的（也就是说一个线程对成员变量的改变会影响到另一个线程）。必须对这种潜在资源冲突进行预防。（一个线程对线程内部的局部变量的改变不会影响到其他的线程。）</p><a id="more"></a>

<p>Java中每个对象都有一个内置锁。使用synchronized关键字给对象和方法或者代码块加锁，当它锁定一个方法或者一个代码块的时候，同一时刻最多只有一个线程执行synchronized锁。</p>
<p>当程序运行到非静态的synchronized同步方法上时，自动获得与正在执行代码类的当前实例（this实例）有关的锁。获得一个对象的锁也称为获取锁、锁定对象、在对象上锁定或在对象上同步。当程序运行到synchronized同步方法或代码块时才该对象锁才起作用。</p>
<p>一个对象只有一个锁。所以，如果一个线程获得该锁，就没有其他线程可以获得锁，直到第一个线程释放（或返回）锁。这也意味着任何其他线程都不能进入该对象上的synchronized方法或代码块。如果线程试图进入被锁的代码，则线程在该对象上被阻塞。实质上，线程进入该对象的的锁池中，必须在那里等待，直到其锁被释放，该线程再次变为可运行或运行为止。释放锁是指持锁线程退出了synchronized同步方法或代码块。</p>
<p>关于锁和同步，有一下几个要点：</p>
<ol>
<li>
<p>只能同步方法和代码块，而不能同步变量和类；</p>
</li>
<li>
<p>不必同步类中所有的方法，类可以同时拥有同步和非同步方法。</p>
</li>
<li>
<p>如果线程拥有同步和非同步方法，则非同步方法可以被多个线程自由访问而不受锁的限制。</p>
</li>
<li>
<p>每个对象只有一个锁。当提到同步时，一定要注意哪个对象正被用于锁定：</p>
<ul>
<li>调用同一个对象中非静态同步方法的线程将彼此阻塞。如果是不同对象，则每个线程有自己的对象的锁，线程间彼此互不干预。</li>
<li>调用同一个类中的静态同步方法的线程将彼此阻塞，它们都是锁定在相同的Class对象上。</li>
<li>静态同步方法和非静态同步方法将永远不会彼此阻塞，因为静态方法锁定在Class对象上，非静态方法锁定在该类的对象上。</li>
<li>对于同步代码块，要看清楚什么对象已经用于锁定（synchronized后面括号的内容）。在同一个对象上进行同步的线程将彼此阻塞，在不同对象上锁定的线程将永远不会彼此阻塞。</li>
</ul>
</li>
<li>
<p>线程睡眠时，它所持的任何锁都不会释放。</p>
</li>
<li>
<p>线程可以获得多个锁。比如，在一个对象的同步方法里面调用另外一个对象的同步方法，则获取了两个对象的同步锁。</p>
</li>
<li>
<p>对于synchronized方法或者synchronized代码块，当出现异常时，JVM会自动释放当前线程占用的锁，因此不会由于异常导致出现死锁现象。</p>
</li>
<li>
<p>同步损害并发性，应该尽可能缩小同步范围。同步不但可以同步整个方法，还可以同步方法中一部分代码块。</p>
</li>
</ol>
<h2 id="Object内置锁">Object内置锁</h2>
<p>Object内置锁，或者又叫监视器（monitor），指的可以是任何对象。也就是说可以使用任何对象给目标代码加锁（Object的特性之一）。同一个对象锁在同一时刻最多只有一个线程访问。</p>
<p>打个比方：可以将object锁看作一个上锁的大房子，房子里有很多房间（也就是被锁的线程代码），房门口放着一把钥匙（key）。所有想调用该对象方法的线程都可以看作想进入这房子某个房间的人。object锁只能允许一个人进入房子。并且每个想进入房间的人都必须拿到钥匙开锁，而且使用完一次后必须马上把钥匙还回去，即使要连续使用两次，中间他也必须把钥匙还回去，再取回来（不能保证第二次还能拿到）。因此，普通情况下钥匙的使用原则是：“随用随借，用完即还”。当某个人需要进入上锁的房子时，就要跑到大门口去看看，有钥匙当然拿了就进去，没有的话，就只能等了。要是很多人在等这把钥匙，等钥匙还回来以后，谁会优先得到钥匙？没有答案。所有在等钥匙的人被叫做Lock pool（锁池），锁池是基于该对象的。</p>
<h1>2.synchronized关键字使用</h1>
<h2 id="synchronized代码块">synchronized代码块</h2>
<p>synchronized代码块：使用 synchronized 关键字修饰，并使用“{}”括起来的代码片段，同一时间只能有一个线程进入到该方法块中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(object) &#123; <span class="comment">//这个object可以为任意对象</span></span><br><span class="line">   <span class="comment">//需要被同步的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="synchronized方法">synchronized方法</h2>
<p>synchronized修饰方法：是用当前对象作为锁，相当于:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(<span class="keyword">this</span>)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">//目标方法代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以，如果一个对象有多个synchronized方法，某一时刻某个线程已经进入到了某个synchronized方法，那么在该方法没有执行完毕前，其他线程是无法访问该对象的任何synchronized方法的。</p>
<p>由此可以得出：synchronized方法是一种粗粒度的并发控制，某一时刻，只能有一个线程执行该synchronized方法；而synchronized块则是一种细粒度的并发控制，只会将块中的代码同步，位于方法内。synchronized块之外的代码是可以被多个线程同时访问到的。</p>
<h2 id="静态方法同步">静态方法同步</h2>
<p>要同步静态方法，需要一个用于整个类对象的锁，这个对象是就是这个类（XXX.class)。</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">setName</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">      Xxx.name = name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>等价于</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">setName</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">      <span class="keyword">synchronized</span>(Xxx.class)&#123;</span><br><span class="line">            Xxx.name = name;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由上面代码可以看到，静态方法同步锁的并不是synchronized方法所在的对象，而是synchronized方法所在的对象所对应的Class对象，因为Java中无论一个类有多少个对象，这些对象会对应唯一一个Class对象，因此当线程分别访问同一个类的两个对象的两个static、synchronized方法时，他们的执行顺序也是顺序的，也就是说一个线程先去执行方法，执行完毕后另一个线程才开始执行。(类同步)</p>
<p>注意：静态同步方法和非静态同步方法将永远不会彼此阻塞，因为静态方法锁定在Class对象上，非静态方法锁定在该类的对象上。</p>
<h1>3.线程之间的相互唤醒</h1>
<p>使用对象锁的wait()与notify()/notifyAll()方法实现在线程之间的相互唤醒。</p>
<p>wait()、notify()、notifyAll()都是Object的实例方法。与每个对象具有锁池一样，每个对象可以有一个等待池（注意与Object锁池区别，两者不是一个东西），它们等待来自该对象的信号（通知）。同步线程通过执行对象上的wait()方法进入这个等待列表。从那时候起，它不再执行任何其他指令，直到调用对象的notify()方法为止。如果多个线程在同一个对象上等待，则将只选择一个线程（不保证以何种顺序）继续执行。如果没有线程等待，则不采取任何特殊操作。</p>
<p>有朋友可能会有疑问：为何这三个不是Thread类声明中的方法，而是Object类中声明的方法（当然由于Thread类继承了Object类，所以Thread也可以调用者三个方法）？其实这个问题很简单，由于每个对象都拥有monitor（即锁），所以让当前线程等待某个对象的锁，当然应该通过这个对象来操作了。而不是用当前线程来操作，因为当前线程可能会等待多个线程的锁，如果通过线程来操作，就非常复杂了。</p>
<p>注意：必须从同步环境内调用wait()、notify()、notifyAll()方法。线程不能调用对象上等待或通知的方法，除非它拥有那个对象的锁。</p>
<p>wait()与notify()方法都是定义在Object类中，而且是final的，因此会被所有的Java类所继承并且无法重写。这两个方法要求在调用时线程应该已经获得了对象的锁，因此对这两个方法的调用需要放在synchronized方法或块当中。如果不在的话会收到一个异常：IllegalMonitorStateException。两个方法通常一起使用。</p>
<p>示例如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">* 计算输出其他线程锁计算的数据 </span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadA</span> </span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">        ThreadB b = <span class="keyword">new</span> ThreadB(); </span><br><span class="line">        <span class="comment">//启动计算线程 </span></span><br><span class="line">        b.start(); </span><br><span class="line">        <span class="comment">//线程A拥有b对象上的锁。线程为了调用wait()或notify()方法，该线程必须是那个对象锁的拥有者 </span></span><br><span class="line">        <span class="keyword">synchronized</span> (b) &#123; </span><br><span class="line">            <span class="keyword">try</span> &#123; </span><br><span class="line">                System.out.println(<span class="string">"等待对象b完成计算。。。"</span>); </span><br><span class="line">                <span class="comment">//当前线程A等待 </span></span><br><span class="line">                b.wait(); </span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; </span><br><span class="line">                e.printStackTrace(); </span><br><span class="line">            &#125; </span><br><span class="line">            System.out.println(<span class="string">"b对象计算的总和是："</span> + b.total); </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">* 计算1+2+3 ... +100的和 </span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadB</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123; </span><br><span class="line">    <span class="keyword">int</span> total; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123; </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">101</span>; i++) &#123; </span><br><span class="line">                total += i; </span><br><span class="line">            &#125; </span><br><span class="line">            <span class="comment">//（完成计算了）唤醒在此对象监视器上等待的单个线程，在本例中线程A被唤醒 </span></span><br><span class="line">            notify(); </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>等待对象b完成计算。。。</p>
<p>b对象计算的总和是：5050</p>
<p>Process finished with exit code 0</p>
<h2 id="Object类的wait-方法">Object类的wait()方法</h2>
<p>wait()：调用后会导致该线程阻塞，不可继续执行，并且该对象上的锁（key）被释放。直到有其它线程调用对象锁的notify()唤醒该线程。相应的notify()就是对wait线程的唤醒操作。 要注意的是当wait线程被唤醒、重新获得锁（key）后，它会从原来阻塞的地方开始继续向下执行，而非重头开始执行。</p>
<p>wait()还有另外两个重载方法：</p>
<ul>
<li><code>void wait(long timeout)</code>：导致当前的线程等待，直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者超过指定的时间量。</li>
<li><code>void wait(long timeout, int nanos)</code>：导致当前的线程等待，直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者其他某个线程中断当前线程，或者已超过某个实际时间量。</li>
</ul>
<p>该对象上的所有wait线程组成了Wait pool（等待池）。Wait pool里面的线程是没有权利获得获得锁（key）的，只有被唤醒，进入了Lock pool（锁池），才有权利获得锁（key）。一个线程被唤醒也不代表立即获取了对象的锁，当前获取锁的线程释放锁后，其余线程才可获得锁执行。</p>
<h2 id="Object类的notify-notifyAll-方法">Object类的notify()/notifyAll()方法</h2>
<p><strong>notify()</strong>： 在相应的<code>synchronized(){}</code> 语句块执行结束之后，唤醒Wait pool里的线程(只唤醒一个)。</p>
<p>注意以下几点：</p>
<ul>
<li>
<p>在调用此方法的时候，并不能确切的唤醒某一个等待状态的线程，而是由JVM确定唤醒哪个线程，而且不是按优先级顺序唤醒。</p>
</li>
<li>
<p>调用对象的notify()方法会导致因调用该对象的wait()方法而阻塞的线程中随机选择的一个解除阻塞（但要等到获得锁（key）后才真正可执行）。</p>
</li>
<li>
<p>当在对象上调用notify()时，并不意味着这时线程会立刻放弃锁。只有线程完成同步代码后，才会放弃锁，此时该锁才会变得可用。这与wait()方法不同，调用wait()方法时，执行该代码的线程立即放弃它在对象上的锁。</p>
</li>
<li>
<p>如果要把notify和wait方法放在一起用的话，必须先调用notify后调用wait，因为如果调用完wait，该线程就已经不是currentthread了。</p>
</li>
</ul>
<p><strong>notifyAll()</strong>：</p>
<p>唤醒Wait pool里的所有线程（但注意同一时间只有一个线程能拿到锁），注意唤醒的是notify之前wait的线程,对于notify之后的wait线程是没有效果的。</p>
<h2 id="锁调度下的线程状态图">锁调度下的线程状态图</h2>
<p>具有wait()和notify()的线程状态图：</p>
<p><img src="https://hexo-1300861231.cos.ap-shanghai.myqcloud.com/1584757125_20200321101433686_12374.png" alt></p>
<p>注意lock pool（锁池）与wait pool（等待池）的区别。只有当前获得锁的线程执行锁对象上的wait()方法才能进入wait pool，而当线程被锁对象的notify()方法唤醒后，会进入lock pool，仅仅得到了获得锁并重新运行的可能性，不一定会立即执行。</p>
<h2 id="并发协作-生产者消费者模型">并发协作-生产者消费者模型</h2>
<p>对于多线程程序来说，不管任何编程语言，生产者和消费者模型都是最经典的。就像学习每一门编程语言一样，Hello World！都是最经典的例子。</p>
<p>实际上，准确说应该是“生产者-消费者-仓储”模型，离开了仓储，生产者消费者模型就显得没有说服力了。</p>
<p>对于此模型，应该明确一下几点：</p>
<ol>
<li>
<p>生产者仅仅在仓储未满时候生产，仓满则停止生产。</p>
</li>
<li>
<p>消费者仅仅在仓储有产品时候才能消费，仓空则等待。</p>
</li>
<li>
<p>当消费者发现仓储没产品可消费时候会通知生产者生产。</p>
</li>
<li>
<p>生产者在生产出可消费产品时候，应该通知等待的消费者去消费。</p>
</li>
</ol>
<p>此模型将要结合<code>java.lang.Object</code>的wait与notify、notifyAll方法来实现以上的需求。这是非常重要的。</p>
<p><strong>示例一</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123; </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">                Godown godown = <span class="keyword">new</span> Godown(<span class="number">30</span>); </span><br><span class="line">                Consumer c1 = <span class="keyword">new</span> Consumer(<span class="number">50</span>, godown); </span><br><span class="line">                Consumer c2 = <span class="keyword">new</span> Consumer(<span class="number">20</span>, godown); </span><br><span class="line">                Consumer c3 = <span class="keyword">new</span> Consumer(<span class="number">30</span>, godown); </span><br><span class="line">                Producer p1 = <span class="keyword">new</span> Producer(<span class="number">10</span>, godown); </span><br><span class="line">                Producer p2 = <span class="keyword">new</span> Producer(<span class="number">10</span>, godown); </span><br><span class="line">                Producer p3 = <span class="keyword">new</span> Producer(<span class="number">10</span>, godown); </span><br><span class="line">                Producer p4 = <span class="keyword">new</span> Producer(<span class="number">10</span>, godown); </span><br><span class="line">                Producer p5 = <span class="keyword">new</span> Producer(<span class="number">10</span>, godown); </span><br><span class="line">                Producer p6 = <span class="keyword">new</span> Producer(<span class="number">10</span>, godown); </span><br><span class="line">                Producer p7 = <span class="keyword">new</span> Producer(<span class="number">80</span>, godown); </span><br><span class="line">                c1.start(); </span><br><span class="line">                c2.start(); </span><br><span class="line">                c3.start(); </span><br><span class="line">                p1.start(); </span><br><span class="line">                p2.start(); </span><br><span class="line">                p3.start(); </span><br><span class="line">                p4.start(); </span><br><span class="line">                p5.start(); </span><br><span class="line">                p6.start(); </span><br><span class="line">                p7.start(); </span><br><span class="line">        &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">* 仓库 </span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Godown</span> </span>&#123; </span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> max_size = <span class="number">100</span>; <span class="comment">//最大库存量 </span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> curnum;     <span class="comment">//当前库存量 </span></span><br><span class="line"></span><br><span class="line">        Godown() &#123; </span><br><span class="line">        &#125; </span><br><span class="line"></span><br><span class="line">        Godown(<span class="keyword">int</span> curnum) &#123; </span><br><span class="line">                <span class="keyword">this</span>.curnum = curnum; </span><br><span class="line">        &#125; </span><br><span class="line"></span><br><span class="line">        <span class="comment">/** </span></span><br><span class="line"><span class="comment">         * 生产指定数量的产品 </span></span><br><span class="line"><span class="comment">         * </span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> neednum </span></span><br><span class="line"><span class="comment">         */</span> </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">produce</span><span class="params">(<span class="keyword">int</span> neednum)</span> </span>&#123; </span><br><span class="line">                <span class="comment">//测试是否需要生产 </span></span><br><span class="line">                <span class="keyword">while</span> (neednum + curnum &gt; max_size) &#123; </span><br><span class="line">                        System.out.println(<span class="string">"要生产的产品数量"</span> + neednum + <span class="string">"超过剩余库存量"</span> + (max_size - curnum) + <span class="string">"，暂时不能执行生产任务!"</span>); </span><br><span class="line">                        <span class="keyword">try</span> &#123; </span><br><span class="line">                                <span class="comment">//当前的生产线程等待 </span></span><br><span class="line">                                wait(); </span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; </span><br><span class="line">                                e.printStackTrace(); </span><br><span class="line">                        &#125; </span><br><span class="line">                &#125; </span><br><span class="line">                <span class="comment">//满足生产条件，则进行生产，这里简单的更改当前库存量 </span></span><br><span class="line">                curnum += neednum; </span><br><span class="line">                System.out.println(<span class="string">"已经生产了"</span> + neednum + <span class="string">"个产品，现仓储量为"</span> + curnum); </span><br><span class="line">                <span class="comment">//唤醒在此对象监视器上等待的所有线程 </span></span><br><span class="line">                notifyAll(); </span><br><span class="line">        &#125; </span><br><span class="line"></span><br><span class="line">        <span class="comment">/** </span></span><br><span class="line"><span class="comment">         * 消费指定数量的产品 </span></span><br><span class="line"><span class="comment">         * </span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> neednum </span></span><br><span class="line"><span class="comment">         */</span> </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">consume</span><span class="params">(<span class="keyword">int</span> neednum)</span> </span>&#123; </span><br><span class="line">                <span class="comment">//测试是否可消费 </span></span><br><span class="line">                <span class="keyword">while</span> (curnum &lt; neednum) &#123; </span><br><span class="line">                        <span class="keyword">try</span> &#123; </span><br><span class="line">                                <span class="comment">//当前的生产线程等待 </span></span><br><span class="line">                                wait(); </span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; </span><br><span class="line">                                e.printStackTrace(); </span><br><span class="line">                        &#125; </span><br><span class="line">                &#125; </span><br><span class="line">                <span class="comment">//满足消费条件，则进行消费，这里简单的更改当前库存量 </span></span><br><span class="line">                curnum -= neednum; </span><br><span class="line">                System.out.println(<span class="string">"已经消费了"</span> + neednum + <span class="string">"个产品，现仓储量为"</span> + curnum); </span><br><span class="line">                <span class="comment">//唤醒在此对象监视器上等待的所有线程 </span></span><br><span class="line">                notifyAll(); </span><br><span class="line">        &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">* 生产者 </span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123; </span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> neednum;                <span class="comment">//生产产品的数量 </span></span><br><span class="line">        <span class="keyword">private</span> Godown godown;            <span class="comment">//仓库 </span></span><br><span class="line"></span><br><span class="line">        Producer(<span class="keyword">int</span> neednum, Godown godown) &#123; </span><br><span class="line">                <span class="keyword">this</span>.neednum = neednum; </span><br><span class="line">                <span class="keyword">this</span>.godown = godown; </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123; </span><br><span class="line">                <span class="comment">//生产指定数量的产品 </span></span><br><span class="line">                godown.produce(neednum); </span><br><span class="line">        &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">* 消费者 </span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123; </span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> neednum;                <span class="comment">//生产产品的数量 </span></span><br><span class="line">        <span class="keyword">private</span> Godown godown;            <span class="comment">//仓库 </span></span><br><span class="line"></span><br><span class="line">        Consumer(<span class="keyword">int</span> neednum, Godown godown) &#123; </span><br><span class="line">                <span class="keyword">this</span>.neednum = neednum; </span><br><span class="line">                <span class="keyword">this</span>.godown = godown; </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123; </span><br><span class="line">                <span class="comment">//消费指定数量的产品 </span></span><br><span class="line">                godown.consume(neednum); </span><br><span class="line">        &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>已经生产了10个产品，现仓储量为40</p>
<p>已经生产了10个产品，现仓储量为50</p>
<p>已经消费了50个产品，现仓储量为0</p>
<p>已经生产了80个产品，现仓储量为80</p>
<p>已经消费了30个产品，现仓储量为50</p>
<p>已经生产了10个产品，现仓储量为60</p>
<p>已经消费了20个产品，现仓储量为40</p>
<p>已经生产了10个产品，现仓储量为50</p>
<p>已经生产了10个产品，现仓储量为60</p>
<p>已经生产了10个产品，现仓储量为70</p>
<p>说明：</p>
<p>对于本例，要说明的是当发现不能满足生产或者消费条件的时候，调用对象的wait方法，释放当前线程的所获得的锁，并调用对象的notifyAll()方法，通知（唤醒）该对象上其他等待线程，使得其继续执行。这样，整个生产者、消费者线程得以正确的协作执行。</p>
<p>notifyAll()方法，起到的是一个通知作用，不释放锁，也不获取锁。只是告诉该对象上等待的线程“可以竞争执行了，都醒来去执行吧”。</p>
<p>本例仅仅是生产者消费者模型中最简单的一种表示，本例中，如果消费者消费的仓储量达不到满足，而又没有生产者，则程序会一直处于等待状态，这当然是不对的。实际上可以将此例进行修改，修改为，根据消费驱动生产，同时生产兼顾仓库，如果仓不满就生产，并对每次最大消费量做个限制，这样就不存在此问题了，当然这样的例子更复杂，更难以说明这样一个简单模型。</p>
<p><strong>示例二</strong></p>
<p>下面示例使用<code>Object.wait()</code>和<code>Object.notify()</code>、非阻塞队列实现生产者-消费者模式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> queueSize = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> PriorityQueue&lt;Integer&gt; queue = <span class="keyword">new</span> PriorityQueue&lt;Integer&gt;(queueSize);</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>  </span>&#123;</span><br><span class="line">        Test test = <span class="keyword">new</span> Test();</span><br><span class="line">        Producer producer = test.new Producer();</span><br><span class="line">        Consumer consumer = test.new Consumer();</span><br><span class="line">        </span><br><span class="line">        producer.start();</span><br><span class="line">        consumer.start();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            consume();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">consume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (queue) &#123;</span><br><span class="line">                    <span class="keyword">while</span>(queue.size() == <span class="number">0</span>)&#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            System.out.println(<span class="string">"队列空，等待数据"</span>);</span><br><span class="line">                            queue.wait();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                            queue.notify();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    queue.poll();          <span class="comment">//每次移走队首元素</span></span><br><span class="line">                    queue.notify();</span><br><span class="line">                    System.out.println(<span class="string">"从队列取走一个元素，队列剩余"</span>+queue.size()+<span class="string">"个元素"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            produce();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">produce</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (queue) &#123;</span><br><span class="line">                    <span class="keyword">while</span>(queue.size() == queueSize)&#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            System.out.println(<span class="string">"队列满，等待有空余空间"</span>);</span><br><span class="line">                            queue.wait();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                            queue.notify();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    queue.offer(<span class="number">1</span>);        <span class="comment">//每次插入一个元素</span></span><br><span class="line">                    queue.notify();</span><br><span class="line">                    System.out.println(<span class="string">"向队列取中插入一个元素，队列剩余空间："</span>+(queueSize-queue.size()));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      </div>
      
      
      
    </div>
    
  <ul class="breadcrumb">
          
            <li><a href="/quotes/">QUOTES</a></li>
            <li><a href="/quotes/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">JAVA学习笔记</a></li>
            <li>42-对象锁与SYNCHRONIZED关键字</li>
          
  </ul>

    
    
    
  </div>


          </div>
          

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#null"><span class="nav-text">1.synchronized锁</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Object内置锁"><span class="nav-text">Object内置锁</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#null"><span class="nav-text">2.synchronized关键字使用</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#synchronized代码块"><span class="nav-text">synchronized代码块</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#synchronized方法"><span class="nav-text">synchronized方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#静态方法同步"><span class="nav-text">静态方法同步</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#null"><span class="nav-text">3.线程之间的相互唤醒</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Object类的wait-方法"><span class="nav-text">Object类的wait()方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Object类的notify-notifyAll-方法"><span class="nav-text">Object类的notify()/notifyAll()方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#锁调度下的线程状态图"><span class="nav-text">锁调度下的线程状态图</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#并发协作-生产者消费者模型"><span class="nav-text">并发协作-生产者消费者模型</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <img class="site-author-image" itemprop="image" alt="jiateng.jiang"
    src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">jiateng.jiang</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">44</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">32</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">jiateng.jiang</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v4.0.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.4.2
  </div>

        












        
      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/pisces.js"></script>
<script src="/js/next-boot.js"></script>



  






  <script src="/js/local-search.js"></script>








<script>
if (document.querySelectorAll('div.pdf').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/pdfobject@2/pdfobject.min.js', () => {
    document.querySelectorAll('div.pdf').forEach(element => {
      PDFObject.embed(element.getAttribute('target'), element, {
        pdfOpenParams: {
          navpanes: 0,
          toolbar: 0,
          statusbar: 0,
          pagemode: 'thumbs',
          view: 'FitH'
        },
        PDFJS_URL: '/lib/pdf/web/viewer.html',
        height: element.getAttribute('height') || '100%'
      });
    });
  }, window.PDFObject);
}
</script>





  

  

  

</body>
</html>
